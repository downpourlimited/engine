<!DOCTYPE html>
<html lang="en">

<!--
    Downpour HTML engine, for rendering Downpour games that are using v18 of the data format

License below applies to everything except the contents of the `data` variable. That belongs to the user.

MIT License

Copyright (c) 2024 Downpour Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->


<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" href="https://downpour.games/favicon.ico" sizes="32x32">
    <link rel="icon" href="https://downpour.games/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="https://downpour.games/apple-touch-icon.png">


    <title>A Downpour game</title>

    <!-- social sharing section -->

    <style>
        html {
            box-sizing: border-box;
            font-size: 16px;

            text-size-adjust: none;
        }

        html,
        body {
            overflow: hidden;
        }

        body {
            display: flex;
            height: 100dvh;
            flex-direction: column;
            justify-content: end;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        p,
        ol,
        ul {
            margin: 0;
            padding: 0;
            font-weight: normal;
        }

        #page_wrapper {
            width: 100%;
            /* grow or shrink as necessary to fill the page */
            flex: 1 1;
            /* ignore height from child page when calculating flex size */
            height: 0;
            /* allow mute button to be absolutely positioned within */
            position: relative;
        }

        #page {
            flex: auto;
            transform-origin: top left;

            touch-action: manipulation;
        }

        #credits {
            background-color: black;
            padding: 4px;
            font-family: 'IBM Plex Sans Condensed', 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            color: #ffffff;
            font-size: 1em;
            display: flex;
            justify-content: space-between;
            align-items: end;
            gap: 10px;
            text-align: center;
            align-items: center;
        }


        .downpour-icon,
        .downpour-icon a,
        .downpour-icon a:visited {
            color: #ffffff;
            flex-shrink: 0;

            text-decoration: none;

            gap: 8px;
            /*padding-bottom: 2px;*/
            display: flex;
            align-items: center;
        }

        .downpour-icon svg {

            height: 25px;
            width: 25px;
        }


        .replay-icon,
        .replay-icon a,
        .replay-icon a:visited {
            height: 21px;
            width: 21px;
            color: #ffffff;
            flex-shrink: 0;

            transition: 0.3s;
            display: inline-block;
        }

        .replay-icon:hover {
            rotate: -45deg;
        }

        #title {
            margin-left: 20px;
            margin-right: 20px;
            font-weight: bold;
            display: flex;
            gap: 8px;
            padding-bottom: 2px;

            align-items: center;
        }

        #author {
            margin-left: 4px;
            margin-right: 4px;
            padding-bottom: 2px;
        }

        #author a,
        #author a:visited {
            color: #ffffff;
            text-decoration: none;
        }

        .username {
            font-style: italic;
        }

        /*we just need this around to hold some filters for us. can't display:none as that stops it working on FF*/
        #svg_filters {
            position: absolute;
            height: 0;
        }

        .media {
            max-width: 100vw;
            max-height: 100vh;
            display: block;
        }

        .link {
            position: absolute;
            display: block;
            box-sizing: border-box;
            filter: url(#filter);
            /*overflow: hidden;*/
            text-decoration: none;

            -webkit-touch-callout: none;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;

            /* fix Safari rendering bug https://graffino.com/til/how-to-fix-filter-blur-performance-issue-in-safari */
            transform: translate3d(0, 0, 0);
        }

        .clickable {
            cursor: pointer;
        }

        .link-asset {
            width: 100%;
            height: 100%;
        }

        .link-text {
            white-space: pre-wrap;
            font-family: sans-serif;
            color: black;
            text-decoration: none;
            overflow-wrap: break-word;
        }

        iframe {
            border-width: 0;
            border-radius: 4px;
        }

        .comment-placeholder {
            font-family: 'IBM Plex Sans Condensed', 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            font-style: italic;
            text-align: center;
            border-radius: 4px;
            background-color: #F0F0FF;
            color: #353783;
            display: grid;
            align-items: center;
            height: 100%;
            padding: 5%;

        }

        .link-with-error {

            background-color: #fff0f0;
            color: #833535;
        }

        .link-error {

            font-family: 'IBM Plex Sans Condensed', 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            text-align: center;
            height: 100%;
            padding: 5%;
            border-radius: inherit;

        }

        #mute_button {
            position: absolute;
            right: 1em;
            bottom: 1em;
            width: 3em;
            height: 3em;
            border-radius: 1.5em;
            border: 0;
            opacity: .3;
        }

        #mute_button>*,
        #mute_button svg {

            width: 100%;
            height: 100%;
        }

        .visually_hidden {
            clip: rect(0 0 0 0);
            clip-path: inset(50%);
            height: 1px;
            overflow: hidden;
            position: absolute;
            white-space: nowrap;
            width: 1px;
        }
    </style>
</head>

<body>
    <div id="page_wrapper">
        <div id="page">
        </div>

        <div>
            <button id="mute_button" hidden>
                <div id="mute_icon">
                    <svg viewBox="0 0 246 246">
                        <path d="M87.077,175.875c-0.358,-0.212 -0.582,-0.596 -0.589,-1.012c-0.007,-0.417 0.203,-0.808 0.554,-1.032l45.999,-29.383c0.383,-0.244 0.87,-0.252 1.26,-0.02c0.39,0.232 0.616,0.665 0.583,1.117c-2.235,33.233 -8.128,47.452 -8.128,47.452c-0.522,1.28 -1.576,2.27 -2.887,2.711c-1.311,0.442 -2.749,0.291 -3.939,-0.413l-32.853,-19.42Z" />
                        <path d="M38.882,148.141c-0.347,0.221 -0.784,0.25 -1.157,0.074c-0.373,-0.175 -0.63,-0.53 -0.68,-0.939c-0.988,-8.088 -2.345,-20.58 -2.345,-28.215c0,-12.007 3.357,-36.023 3.357,-36.023c0.329,-2.345 2.333,-4.09 4.701,-4.096l16.143,-0.036l63.854,-36.149c1.274,-0.721 2.809,-0.816 4.162,-0.256c1.354,0.56 2.373,1.712 2.765,3.122c0,0 3.439,12.228 5.129,40.51c0.027,0.435 -0.184,0.85 -0.551,1.084l-95.378,60.924Z" />
                        <path d="M167.127,123.232c0.033,-0.371 0.236,-0.706 0.549,-0.907c1.911,-1.22 8.812,-5.629 12.095,-7.726c0.365,-0.233 0.826,-0.251 1.208,-0.049c0.383,0.203 0.626,0.595 0.638,1.028c0.019,0.702 0.029,1.408 0.029,2.115c-0,20.773 -8.358,39.61 -21.892,53.327c-2.766,2.804 -7.288,2.834 -10.092,0.068c-2.804,-2.766 -2.834,-7.288 -0.068,-10.092c9.774,-9.906 16.225,-23.1 17.533,-37.764Z" />
                        <path d="M152.451,75.598c-0.291,0.186 -0.647,0.237 -0.979,0.142c-0.331,-0.096 -0.606,-0.329 -0.753,-0.641c-1.28,-2.793 -0.662,-6.212 1.754,-8.353c2.948,-2.613 7.462,-2.341 10.074,0.607l0.086,0.097c0.232,0.263 0.338,0.614 0.289,0.961c-0.049,0.347 -0.247,0.656 -0.542,0.845l-9.929,6.342Z" />
                        <path d="M209.797,95.42c0.338,-0.216 0.76,-0.249 1.127,-0.089c0.366,0.16 0.629,0.493 0.7,0.886c1.192,6.708 1.815,13.613 1.815,20.661c-0,32.12 -12.923,61.245 -33.85,82.455c-2.766,2.803 -7.288,2.834 -10.092,0.067c-2.804,-2.766 -2.834,-7.288 -0.068,-10.092c18.383,-18.631 29.737,-44.215 29.737,-72.43c0,-4.768 -0.324,-9.462 -0.952,-14.059l11.583,-7.399Z" />
                        <path d="M191.8,48.972c0.189,0.268 0.261,0.602 0.198,0.924c-0.063,0.322 -0.255,0.604 -0.532,0.78l-10.019,6.401c-0.538,0.343 -1.251,0.206 -1.622,-0.313c-2.059,-2.865 -4.262,-5.62 -6.597,-8.254c-2.612,-2.948 -2.34,-7.462 0.607,-10.074c2.948,-2.613 7.462,-2.341 10.074,0.607c2.803,3.162 5.438,6.477 7.891,9.929Z" />
                        <path d="M30.792,192.825c-4.425,2.827 -10.313,1.529 -13.14,-2.897c-2.827,-4.426 -1.529,-10.314 2.896,-13.141l194.42,-124.186c4.425,-2.827 10.313,-1.529 13.14,2.896c2.827,4.426 1.529,10.314 -2.896,13.141l-194.42,124.187Z" />
                    </svg>
                    <span class="visually_hidden">Mute</span>
                </div>
                <div id="unmute_icon" hidden>
                    <svg viewBox="0 0 246 246" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;">
                        <g id="unmuted">
                            <path d="M42.768,83.7c0,-0 -3.31,23.574 -3.31,35.361c-0,11.789 3.31,35.375 3.31,35.375l17.391,-0l0,-70.775l-17.391,0.039Z" style="stroke:#000;stroke-width:9.52px;" />
                            <path d="M60.159,83.661l64.94,-36.764c-0,0 5.871,21.132 5.871,72.151c0,51.02 -8.619,72.152 -8.619,72.152l-62.192,-36.764" style="stroke:#000;stroke-width:9.52px;" />
                            <path d="M157.207,72.086c10.764,12.145 17.302,28.119 17.302,45.607c0,18.821 -7.573,35.887 -19.835,48.315" style="fill:none;stroke:#000;stroke-width:14.27px;" />
                            <path d="M178.569,43.776c17.253,19.467 27.733,45.07 27.733,73.102c0,30.168 -12.138,57.522 -31.793,77.443" style="fill:none;stroke:#000;stroke-width:14.27px;" />
                        </g>
                    </svg>

                    <span class="visually_hidden">Unmute</span>
                </div>
            </button>
        </div>
    </div>

    <div id="credits">
        <div class="downpour-icon">


            <a href="https://downpour.games">


                <svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" version="1.1" viewBox="0 0 25 25" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" title="downpour.games">
                    <g>
                        <path fill="currentColor" d="m12.991 10.256v9.428c-0 8e-3 -0 0.017-1e-3 0.025-0 0-0.034 0.61 0.142 1.091 0.064 0.172 0.14 0.353 0.339 0.346 0.142-5e-3 0.251-0.03 0.331-0.088 0.122-0.089 0.161-0.24 0.191-0.402 0.055-0.297 0.042-0.638 0.039-0.953-3e-3 -0.276 0.219-0.502 0.495-0.505s0.502 0.219 0.505 0.495c4e-3 0.378 0.01 0.787-0.056 1.144-0.078 0.428-0.259 0.79-0.582 1.027-0.217 0.159-0.502 0.268-0.888 0.282-0.68 0.023-1.097-0.416-1.312-1.002-0.221-0.601-0.207-1.351-0.203-1.467l5e-3 -9.438c-1e-3 -0.034-0-0.117-0.045-0.155-0.049-0.042-0.151-0.027-0.153-0.026-0.651 0.064-1.199 0.218-1.798 0.421-0.623 0.212-1.243 0.472-1.912 0.725-0.025 0.01-0.052 0.017-0.078 0.023-0.157 0.031-0.319-0.014-0.437-0.121-1.082-0.988-2.306-0.847-3.256-0.475-1.013 0.395-1.739 1.052-1.739 1.052-0.147 0.134-0.36 0.168-0.542 0.086s-0.297-0.264-0.294-0.464c-0 0 0.044-3.142 2.33-5.642 1.459-1.596 3.833-2.948 7.72-3.008 0.109-2e-3 0.196-0.091 0.196-0.2v-0.638c-0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5v0.675c1e-3 0.089 0.072 0.161 0.161 0.162 3.908 0.053 6.292 1.409 7.756 3.009 2.286 2.5 2.33 5.642 2.33 5.642 3e-3 0.2-0.113 0.382-0.294 0.464-0.182 0.082-0.395 0.048-0.542-0.086-0-0-0.726-0.657-1.739-1.052-0.951-0.372-2.174-0.513-3.257 0.475-0.118 0.107-0.28 0.152-0.436 0.121-0.027-6e-3 -0.054-0.013-0.08-0.024-0.648-0.248-1.148-0.569-1.653-0.749-0.582-0.207-1.131-0.305-1.681-0.365l-0.344-0.031c-0.056-5e-3 -0.111 0.013-0.153 0.051-0.041 0.038-0.065 0.091-0.065 0.147zm-2.599-6.512c-2.696 0.307-4.449 1.355-5.582 2.594-1.226 1.34-1.725 2.887-1.928 3.897 0.305-0.186 0.669-0.379 1.071-0.536 0.992-0.387 2.205-0.56 3.375 0.028 0.034-1.842 0.919-4.215 3.064-5.983zm7.257 5.983c1.17-0.588 2.383-0.415 3.375-0.028 0.402 0.157 0.766 0.35 1.072 0.537-0.204-1.011-0.704-2.558-1.929-3.898-1.133-1.239-2.886-2.287-5.583-2.594 2.146 1.768 3.031 4.141 3.065 5.983zm-5.161-6.191c-0.025 0.021-0.054 0.041-0.084 0.057-2.986 1.617-4.135 4.39-4.08 6.349 0.814-0.389 2.294-0.939 4.164-0.939 2.008-0 3.394 0.507 4.165 0.898 0.038-1.957-1.115-4.703-4.08-6.308-0.031-0.016-0.059-0.036-0.085-0.057zm-6.017 9.439c1.013 1.684 1.843 2.544 1.854 4.139 0.011 1.7-1.289 2.399-2.395 2.378-1.103-0.021-2.27-0.794-2.26-2.469 5e-3 -0.817 0.238-1.433 0.623-2.076 0.339-0.567 0.807-1.159 1.327-1.981l0.433-0.685 0.418 0.694zm-0.277 1.43c-0.036-0.055-0.098-0.089-0.164-0.09-0.067-0-0.129 0.032-0.167 0.087-0.272 0.389-0.514 0.728-0.712 1.059-0.291 0.486-0.477 0.949-0.481 1.569-6e-3 0.972 0.639 1.45 1.279 1.462 0.637 0.012 1.382-0.393 1.376-1.371-6e-3 -0.8-0.278-1.37-0.671-2.005-0.14-0.227-0.295-0.46-0.46-0.711zm13.533-1.468c1.323 1.797 1.949 2.567 1.959 4.177 0.011 1.7-1.288 2.399-2.394 2.378-1.104-0.021-2.27-0.794-2.26-2.469 5e-3 -0.813 0.241-1.444 0.615-2.091 0.331-0.574 0.778-1.165 1.247-1.954l0.386-0.648 0.447 0.607zm-0.196 1.412c-0.039-0.052-0.101-0.082-0.166-0.08s-0.125 0.035-0.161 0.09c-0.259 0.388-0.495 0.733-0.691 1.072-0.286 0.496-0.477 0.975-0.481 1.599-6e-3 0.972 0.638 1.45 1.279 1.462 0.636 0.012 1.382-0.393 1.375-1.371-7e-3 -1.124-0.403-1.756-1.155-2.772z" />
                    </g>
                </svg>
                <span class="visually_hidden">downpour.games</span>

            </a>
        </div>

        <div id="title">
            <div id="game-title"></div>
            <a id="replayButton" class="replay-icon" href="?">
                <svg xmlns=" http://www.w3.org/2000/svg" viewBox="0 -960 960 960" title="Restart game">
                    <path fill="currentColor" d="M480-80q-75 0-140.5-28T225-185q-49-49-77-114.5T120-440q0-13 8.5-21.5T150-470q13 0 21.5 8.5T180-440q0 125 87.5 212.5T480-140q125 0 212.5-87.5T780-440q0-125-85-212.5T485-740h-22l52 52q9 9 9 21t-9 21q-9 9-21 9t-21-9L368-751q-9-9-9-21t9-21l106-106q8-8 20.5-8t20.5 8q8 8 8 20.5t-8 20.5l-58 58h23q75 0 140.5 28T735-695q49 49 77 114.5T840-440q0 75-28 140.5T735-185q-49 49-114.5 77T480-80Z" />
                </svg>
                <span class="visually_hidden">Replay</span>
            </a>

        </div>

        <div id="author">
            <span id="game-author"></span>
        </div>

    </div>

    <svg id="svg_filters">
    </svg>



    <script src="data.js"></script>

    <script type="text/javascript">
        const KIOSK_MODE = false;
        const TAG = null;
    </script>


    <script type="text/javascript">
        const LOCAL = true;
    </script>

    <script type="text/javascript">

        if (data.format_version != 18) {
            console.error(`Trying to load gameplay data with version ${data.format_version}, which is not 18`);
        }

        if (LOCAL) {
            document.title = data.name ?? "";
        }

        if (data.name) {
            document.getElementById("game-title").textContent = data.name;
        }
        else if (LOCAL) {
            document.getElementById("game-title").textContent = "";
        }

        if (data.author) {
            document.getElementById("game-author").textContent = data.author;
        }
        else if (LOCAL) {
            document.getElementById("game-author").textContent = "";
        }


        let currentPageWidth = 1000;
        let currentPageHeight = 1000;


        window.addEventListener("hashchange", onHashChange, false);
        function onHashChange(event) {
            let destination = null;
            if (window.location.hash == "") {
                destination = data.initial_page;
            }
            else {
                destination = window.location.hash.substring(1);
            }

            var success = loadPage(destination);
            if (!success) {
                console.error("Page not found: " + destination);
            }
        }

        addEventListener("popstate", popstate);
        function popstate(event) {
            var queryParams = new URLSearchParams(window.location.search);
            if (queryParams.has("p")) {
                destination = queryParams.get("p");
            }
            else {
                destination = data.initial_page;
            }

            var success = loadPage(destination);
            if (!success) {
                console.error("Page not found: " + destination);
                loadPage(data.initial_page);
            }
        }
        const replayButton = document.getElementById("replayButton");
        replayButton.addEventListener("click", (e) => {
            e.preventDefault();
            goToPage(data.initial_page);
        });


        window.addEventListener("resize", setPageScale);
        window.addEventListener("scroll", setPageScale); //to deal with dynamic viewport size
        function setPageScale() {
            var page_wrapper_div = document.getElementById("page_wrapper");
            var page_div = document.getElementById("page");
            var scale = Math.min(1, Math.min(page_wrapper_div.offsetWidth / page_div.offsetWidth, page_wrapper_div.offsetHeight / page_div.offsetHeight));
            page_div.style.scale = `${scale}`;
            page_div.style.translate = `${(page_wrapper_div.offsetWidth - page_div.offsetWidth * scale) / 2.0}px ${(page_wrapper_div.offsetHeight - page_div.offsetHeight * scale) / 2.0}px`;
        }


        const muteButton = document.getElementById("mute_button");
        let muted = true;
        let muteable_links_shown = false;
        muteButton.addEventListener("click", (ev) => {
            muted = !muted;

            for (const video of document.querySelectorAll("video")) {
                video.muted = muted;
            }

            showMuteButton(muted);
        });


        // TODO: can we replace this with https://gist.github.com/binarymax/0c12f01056c1ab947216c7d49ba58d72 ?

        // parse color, so we can manually set up the SVGs for tint rendering
        /**
         * Parse color from the string passed
         * source: https://github.com/colorjs/color-parse/blob/master/index.js
         *
         * This function MIT licensed, here it is:
                The MIT License (MIT)
    
                Copyright (c) 2015 Dmitry Ivanov
    
                Permission is hereby granted, free of charge, to any person obtaining a copy
                of this software and associated documentation files (the "Software"), to deal
                in the Software without restriction, including without limitation the rights
                to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                copies of the Software, and to permit persons to whom the Software is
                furnished to do so, subject to the following conditions:
    
                The above copyright notice and this permission notice shall be included in
                all copies or substantial portions of the Software.
    
                THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                THE SOFTWARE.
         * 
         * @return {Object} A space indicator `space`, an array `values` and `alpha`
         */
        function parseColor(cstr) {
            var m, parts = [], alpha = 1, space

            if (typeof cstr === 'string') {

                //reserved words
                if (cstr === 'transparent') {
                    alpha = 0
                    space = 'rgb'
                    parts = [0, 0, 0]
                }

                //hex
                else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
                    var base = cstr.slice(1)
                    var size = base.length
                    var isShort = size <= 4
                    alpha = 1

                    if (isShort) {
                        parts = [
                            parseInt(base[0] + base[0], 16),
                            parseInt(base[1] + base[1], 16),
                            parseInt(base[2] + base[2], 16)
                        ]
                        if (size === 4) {
                            alpha = parseInt(base[3] + base[3], 16) / 255
                        }
                    }
                    else {
                        parts = [
                            parseInt(base[0] + base[1], 16),
                            parseInt(base[2] + base[3], 16),
                            parseInt(base[4] + base[5], 16)
                        ]
                        if (size === 8) {
                            alpha = parseInt(base[6] + base[7], 16) / 255
                        }
                    }

                    if (!parts[0]) parts[0] = 0
                    if (!parts[1]) parts[1] = 0
                    if (!parts[2]) parts[2] = 0

                    space = 'rgb'
                }

                //color space
                else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
                    var name = m[1]
                    var isRGB = name === 'rgb'
                    var base = name.replace(/a$/, '')
                    space = base
                    var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3
                    parts = m[2].trim()
                        .split(/\s*[,\/]\s*|\s+/)
                        .map(function (x, i) {
                            //<percentage>
                            if (/%$/.test(x)) {
                                //alpha
                                if (i === size) return parseFloat(x) / 100
                                //rgb
                                if (base === 'rgb') return parseFloat(x) * 255 / 100
                                return parseFloat(x)
                            }
                            //hue
                            else if (base[i] === 'h') {
                                //<deg>
                                if (/deg$/.test(x)) {
                                    return parseFloat(x)
                                }
                                //<base-hue>
                                else if (baseHues[x] !== undefined) {
                                    return baseHues[x]
                                }
                            }
                            return parseFloat(x)
                        })

                    if (name === base) parts.push(1)
                    alpha = (isRGB) ? 1 : (parts[size] === undefined) ? 1 : parts[size]
                    parts = parts.slice(0, size)
                }

                //named channels case
                else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
                    parts = cstr.match(/([0-9]+)/g).map(function (value) {
                        return parseFloat(value)
                    })

                    space = cstr.match(/([a-z])/ig).join('').toLowerCase()
                }
            }

            //numeric case
            else if (!isNaN(cstr)) {
                space = 'rgb'
                parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff]
            }

            //array-like
            else if (Array.isArray(cstr) || cstr.length) {
                parts = [cstr[0], cstr[1], cstr[2]]
                space = 'rgb'
                alpha = cstr.length === 4 ? cstr[3] : 1
            }

            //object case - detects css cases of rgb and hsl
            else if (cstr instanceof Object) {
                if (cstr.r != null || cstr.red != null || cstr.R != null) {
                    space = 'rgb'
                    parts = [
                        cstr.r || cstr.red || cstr.R || 0,
                        cstr.g || cstr.green || cstr.G || 0,
                        cstr.b || cstr.blue || cstr.B || 0
                    ]
                }
                else {
                    space = 'hsl'
                    parts = [
                        cstr.h || cstr.hue || cstr.H || 0,
                        cstr.s || cstr.saturation || cstr.S || 0,
                        cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
                    ]
                }

                alpha = cstr.a || cstr.alpha || cstr.opacity || 1

                if (cstr.opacity != null) alpha /= 100
            }

            return {
                space: space,
                values: parts,
                alpha: alpha
            }
        }
        function easeInQuad(x) {
            return x * x;
        }
        function lerp(v0, v1, t) {
            return v0 * (1 - t) + v1 * t;
        }

        /**
         * Description
         * @param {Color} color
         * @returns {void}
         */
        function makeTintFilter(parsedColor) {

            //create the filter
            var xmlns = "http://www.w3.org/2000/svg";
            var svg = document.getElementById("svg_filters");
            var filter = document.createElementNS(xmlns, "filter");
            var id = Math.random().toString(36).substr(2, 9);
            filter.id = id;
            var colorMatrix = document.createElementNS(xmlns, "feColorMatrix");
            filter.appendChild(colorMatrix);
            colorMatrix.setAttribute("type", "matrix");
            colorMatrix.setAttribute("color-interpolation-filters", "sRGB");

            //prep values from the selected color
            let r = parsedColor.values[0] / 255;
            let g = parsedColor.values[1] / 255;
            let b = parsedColor.values[2] / 255;
            let a = parsedColor.alpha;
            let lightness = (Math.max(r, Math.max(g, b)) + Math.min(r, Math.min(g, b))) / 2;
            var light = easeInQuad(lightness);
            var invLight = easeInQuad(1 - lightness);

            //it's big matrix time!
            let vals = [
                lerp(1, lerp(1.0, r, light) * 0.2989, a),
                lerp(0, lerp(1.0, r, light) * 0.5870, a),
                lerp(0, lerp(1.0, r, light) * 0.1140, a),
                0,
                a * invLight * r,
                lerp(0, lerp(1.0, g, light) * 0.2989, a),
                lerp(1, lerp(1.0, g, light) * 0.5870, a),
                lerp(0, lerp(1.0, g, light) * 0.1140, a),
                0,
                a * invLight * g,
                lerp(0, lerp(1.0, b, light) * 0.2989, a),
                lerp(0, lerp(1.0, b, light) * 0.5870, a),
                lerp(1, lerp(1.0, b, light) * 0.1140, a),
                0,
                a * invLight * b,
                0,
                0,
                0,
                1,
                0
            ];

            colorMatrix.setAttribute('values', vals.join(" "));
            svg.appendChild(filter);
            return id;
        }


        /**
         * Description
         * @param {any} link
         * @param {HTMLDivElement} link_element
         * @returns {void}
         */
        function renderLink(link, link_element) {


            //add link properties to dataset, so CSS can pick it up
            const ignored_keys = ["image", "text"]; //string representation isn't helpful, so skip it
            for (const [key, val] of Object.entries(link)) {
                if (!ignored_keys.includes(key)) {
                    link_element.dataset[key] = val;
                }
            }
            if (link.type === "image") {


                //add image properties to dataset, so CSS can pick it up
                const ignored_keys = [];
                for (const [key, val] of Object.entries(link.image)) {
                    if (!ignored_keys.includes(key)) {
                        link_element.dataset[key] = val;
                    }
                }

                //render the image
                let asset = data.assets.find(a => a.id === link.image.asset_id);
                let media_element;

                media_element = document.createElement("img");
                media_element.classList.add("link-asset");
                media_element.draggable = false;
                if (LOCAL) {
                    media_element.src = "media/" + asset.path;
                }
                else {
                    media_element.src = asset.url;
                }
                link_element.appendChild(media_element);

                var filter = "";

                //set up tint magic
                let parsedColor = parseColor(link.image.bg_c);
                if (parsedColor.alpha > 0.001) {
                    let tint_id = makeTintFilter(parsedColor);
                    filter += ` url(#${tint_id})`;
                }

                if (link.image.blur > 0.001) {
                    var smaller_axis = Math.min(link.w, link.h);
                    //0.5 to match Flutter, visually
                    filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
                }
                link_element.style.filter = filter;

                if (link.image.b_width > 0.001) {
                    link_element.style.borderWidth = `${link.image.b_width}px`;
                    link_element.style.borderStyle = "solid";
                    link_element.style.borderColor = link.image.b_c;

                }

                if (link.image.b_radius > 0.001) {
                    link_element.style.borderRadius = `${link.image.b_radius}px`;
                    media_element.style.borderRadius = `${link.image.b_radius - (link.image.b_width ?? 0)}px`;
                }
            }
            else if (link.type === "video") {

                //add image properties to dataset, so CSS can pick it up
                const ignored_keys = [];
                for (const [key, val] of Object.entries(link.image)) {
                    if (!ignored_keys.includes(key)) {
                        link_element.dataset[key] = val;
                    }
                }

                //render the video
                let asset = data.assets.find(a => a.id === link.image.asset_id);

                let loop_setting = link.video.repeat; // "loop", "once" or "goTo"
                let volume_setting = link.video.volume; // 0 - 1
                let speed_setting = link.video.speed; // 0.1 - 4

                let media_element = document.createElement("video");
                media_element.autoplay = true;
                media_element.controls = false;
                media_element.loop = loop_setting == "loop";
                media_element.volume = volume_setting;
                media_element.playbackRate = speed_setting;
                media_element.muted = muted;
                media_element.playsInline = true;

                if (volume_setting > 0) {
                    muteable_links_shown = true;
                }

                if (loop_setting == "goTo") {
                    media_element.addEventListener("ended", (e) => {
                        var auto_to_setting = link.video.auto_to;
                        if (auto_to_setting.startsWith("#")) {
                            let stripped_to = link.video.auto_to.substring(1);

                            goToPage(stripped_to, e);
                        }
                        else if (auto_to_setting == "!random") {
                            goToRandom(link.video.auto_random_to, e);
                        }
                        else if (!auto_to_setting.startsWith("!"))
                            window.location = auto_to_setting;
                    });
                }

                media_element.classList.add("link-asset");
                media_element.draggable = false;
                if (LOCAL) {
                    media_element.src = "media/" + asset.path;
                }
                else {
                    media_element.src = asset.url;
                }
                //unlike images, videos won't load over a file url. so we want to show an error instead
                if (URL.parse(media_element.src).protocol != "file:") {
                    link_element.appendChild(media_element);


                    var filter = "";

                    //we don't want to tint or blur the error message
                    let parsedColor = parseColor(link.image.bg_c);
                    if (parsedColor.alpha > 0.001) {
                        let tint_id = makeTintFilter(parsedColor);
                        filter += ` url(#${tint_id})`;
                    }

                    if (link.image.blur > 0.001) {
                        var smaller_axis = Math.min(link.w, link.h);
                        //0.5 to match Flutter, visually
                        filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
                    }
                    link_element.style.filter = filter;

                }
                else {
                    let error_element = document.createElement("div");
                    error_element.innerText = "Error: Video cannot be displayed when running Downpour games from the file system. It'll work when you put the game online, though.";
                    error_element.classList.add("link-error");
                    link_element.classList.add("link-with-error");
                    link_element.appendChild(error_element);
                }

                // we want to show the border and border radius no matter if we're displaying the video or an error message
                if (link.image.b_width > 0.001) {
                    link_element.style.borderWidth = `${link.image.b_width}px`;
                    link_element.style.borderStyle = "solid";
                    link_element.style.borderColor = link.image.b_c;

                }

                if (link.image.b_radius > 0.001) {
                    link_element.style.borderRadius = `${link.image.b_radius}px`;
                    media_element.style.borderRadius = `${link.image.b_radius - (link.image.b_width ?? 0)}px`;
                }

            }
            else if (link.type === "empty") {

                //add image properties to dataset, so CSS can pick it up
                const ignored_keys = [];
                for (const [key, val] of Object.entries(link.image)) {
                    if (!ignored_keys.includes(key)) {
                        link_element.dataset[key] = val;
                    }
                }

                link_element.style.backgroundColor = link.image.bg_c;


                var filter = "";

                if (link.image.blur > 0.001) {
                    var smaller_axis = Math.min(link.w, link.h);
                    //0.5 to match Flutter, visually
                    filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
                }
                link_element.style.filter = filter;


                if (link.image.b_width > 0.001) {
                    link_element.style.borderWidth = `${link.image.b_width}px`;
                    link_element.style.borderStyle = "solid";
                    link_element.style.borderColor = link.image.b_c;
                }

                if (link.image.b_radius > 0.001) {
                    link_element.style.borderRadius = `${link.image.b_radius}px`;
                }

            }
            else if (link.type === "text") {

                const text_element = document.createElement("div");
                text_element.classList.add("link-text");
                text_element.textContent = link.text.text;
                text_element.style.fontSize = `${link.text.size}px`;
                text_element.style.color = link.text.c;
                text_element.style.textAlign = link.text.h_a;

                // do vertical alignment
                link_element.style.display = "flex";
                link_element.style.flexDirection = "column";
                if (link.text.v_a === "top") {
                    link_element.style.justifyContent = "start";
                }
                else if (link.text.v_a === "middle") {
                    link_element.style.justifyContent = "center";
                }
                else if (link.text.v_a === "bottom") {
                    link_element.style.justifyContent = "end";
                }

                //set font family. note: we loaded these fonts earlier
                text_element.style.fontFamily = link.text.font;

                //unless it has an ital (or slnt) axis, apply italics the old fashioned way
                if (!["Anybody", "Gluten", "Recursive"].includes(link.text.font)) {
                    //if it's set & over 0.5, make it italic, else normal
                    text_element.style.fontStyle = link.text["ital"] ?? 0 > 0.5 ? "italic" : "normal";
                }

                //font variation axes, and their defaults
                const axes = { "wght": 400, 'ital': 0, 'wdth': 100, 'opsz': 20, 'MONO': 0, 'ELSH': 2, 'CASL': 0, 'slnt': 0, 'INFM': 0, 'BNCE': 0 };
                // use specified axis, or the default. string format like: `'ital' 0.345, 'wght' 900`
                text_element.style.fontVariationSettings = Object.keys(axes).map((a) => `'${a}' ${link.text[a] ?? axes[a]}`).join(", ");

                text_element.style.letterSpacing = `${link.text.spacing ?? 0}em`;
                text_element.style.transform = `translate(${link.text.spacing * 0.5 ?? 0}em,0px)`;


                let shadows = [];
                let drawGlowShadow = (link.text.s1_r > 0 && parseColor(link.text.s1_c).alpha > 0);
                let drawDropShadow = (link.text.s2_d > 0 && parseColor(link.text.s2_c).alpha > 0);
                if (drawGlowShadow) {
                    // glow shadow is visible
                    shadows.push(`${link.text.s1_c} 0 0 ${link.text.s1_r * link.text.size}px`);
                }

                if (drawDropShadow) {
                    let x = link.text.s2_d * Math.cos(link.text.s2_a ?? Math.PI * 0.25) * link.text.size;
                    let y = link.text.s2_d * Math.sin(link.text.s2_a ?? Math.PI * 0.25) * link.text.size;

                    shadows.push(`${link.text.s2_c} ${x}px ${y}px 0`);

                    if (drawGlowShadow) {
                        // glow shadow for the drop shadow
                        shadows.push(`${link.text.s2_c} ${x}px ${y}px ${link.text.s1_r * link.text.size}px`);
                    }
                }
                text_element.style.textShadow = shadows.join(",");


                link_element.style.backgroundColor = link.text.b_c;
                link_element.appendChild(text_element);
            }
            else if (link.type === "comments") {
                const comment_url = makeCommentUrl(link, true);
                if (LOCAL || comment_url == null) {

                    const comment_placeholder = document.createElement("div");
                    comment_placeholder.classList.add("comment-placeholder");
                    comment_placeholder.textContent = "Comments only work when the game is uploaded to downpour.games";
                    link_element.appendChild(comment_placeholder);
                }
                else {

                    const comment_iframe = document.createElement("iframe");
                    comment_iframe.style.width = "100%";
                    comment_iframe.style.height = "100%";
                    comment_iframe.src = comment_url;
                    link_element.appendChild(comment_iframe);
                }
            }
            else {
                console.error(`Unknown link type ${link.type}`);
            }



        }

        function makeCommentUrl(link, iframe = false) {
            const match = window.location.pathname.match(/^\/~(?<username>[A-Za-z0-9][A-Za-z0-9_\-]{0,29})\/(?<slug>[A-Za-z0-9\-]+)\/?$/);
            if (match === null) {
                // probably local! or we can't parse the url
                return null;
            }
            const { username, slug } = match.groups;
            const comment_block_id = link.comments.id;

            return `${window.location.origin}/comments/~${username}/${slug}/${comment_block_id}${iframe ? "/iframe" : ""}`;
        }

        function minBy(array, pluck) {
            return array.reduce((min, x) => min && pluck(min) <= pluck(x) ? min : x, null);
        }

        function loadPage(pageId) {
            document.getElementById("svg_filters").innerHTML = ""; //clear old tint filters

            var page = data.pages.find(x => x.id === pageId);

            // if we can't find it, check if it's been renamed
            if (!page) {
                let previously = data.pages.filter(p => p.prev_ids?.includes(pageId));
                if (previously.length > 0) {
                    page = minBy(previously, p => p.prevIds?.indexOf(pageId));
                }
            }

            if (!page) {
                return false;
            }

            muteable_links_shown = false;

            if (page.bg_c) {
                document.body.style.background = page.bg_c;
            }

            currentPageWidth = page.width;
            currentPageHeight = page.height;

            var page_div = document.getElementById("page");
            page_div.innerHTML = "";
            page_div.style.width = `${page.width}px`;
            page_div.style.height = `${page.height}px`;

            //needed so that touch-action: manipulation; applies to non-clickable areas
            page_div.addEventListener('click', () => { })

            setPageScale();


            for (const link of page.links) {

                var link_element = document.createElement((link.to || link.type == "comments") ? "a" : "div");
                if (link.type == "comments") {
                    //the iframe handles the click
                    link_element.style.cursor = "default";
                }
                else if (link.to == "!random") {
                    link_element.addEventListener("click", (e) => goToRandom(link.randomTo, e));
                    link_element.classList.add("clickable");
                }
                else if (link.to == "!blocker") {
                    // do nothing, but block clicks
                }
                else if (link.to === null || link.to === "") {
                    //doesn't link anywhere, doesn't block clicks
                    link_element.style.pointerEvents = "none";
                }
                else {
                    if (link.to.startsWith("#")) {
                        let strippedTo = link.to.substring(1);
                        link_element.href = `?p=${strippedTo}`;
                        link_element.addEventListener("click", (e) => {
                            e.preventDefault();
                            goToPage(strippedTo, e);
                        });
                    }
                    else {
                        if (KIOSK_MODE && TAG) {
                            const internalMatch = link.to.match(/^https?:\/\/(downpour\.games|gordon:\d+|staging\.downpour\.games)\/~(?<username>[A-Za-z0-9][A-Za-z0-9_\-]{0,29})\/(?<slug>[A-Za-z0-9\-]+)\/?/);
                            if (internalMatch != null) {
                                link_element.href = "https://" + new URL(link.to).host + "/eventkiosk/" +
                                    TAG + "/~" + internalMatch.groups["username"] + "/" + internalMatch.groups["slug"];
                            }
                            else {
                                console.log(`Not adding non-Downpour link to event_kiosk page (${pageId}) : ${link.to}`);
                            }
                        }
                        else {
                            link_element.href = link.to;
                        }

                    }
                    link_element.classList.add("clickable");
                }
                link_element.classList.add("link");
                link_element.style.left = link.x + "px";
                link_element.style.top = link.y + "px";
                link_element.style.width = link.w + "px";
                link_element.style.height = link.h + "px";
                link_element.draggable = false;

                renderLink(link, link_element);

                page_div.appendChild(link_element);
            }

            if (muteable_links_shown) {
                showMuteButton(muted);
            }
            else {
                hideMuteButton();
            }

            window.scrollTo(0, 0);

            // window.addEventListener('load', (event) => {
            preload(data, page);
            // });
            return true;
        }



        function showMuteButton(currentlyMuted) {

            muteButton.hidden = false;

            const muteIcon = document.getElementById("mute_icon");
            const unmuteIcon = document.getElementById("unmute_icon");

            if (currentlyMuted) {
                muteIcon.hidden = false;
                unmuteIcon.hidden = true;
            }
            else {
                muteIcon.hidden = true;
                unmuteIcon.hidden = false;
            }
        }

        function hideMuteButton() {

            muteButton.hidden = true;
        }

        /**
         * Go to page
         * @param {String} to
         * @returns {void}
         * */
        function goToPage(to) {
            console.log("go to page", to);

            const url = new URL(location);
            url.searchParams.set("p", to);
            history.pushState({}, "", url);

            loadPage(to);
            // window.open(to, "_self");
        }

        function goToRandom(randomTo, event) {

            if (randomTo == null || randomTo.length == 0) {
                console.log("go to random page, but no random page options");
            }
            else {

                let cum = 0;
                let weights = [];
                for (let r of randomTo) {
                    cum += r.weight ?? 1;
                    weights.push(cum);
                }

                var rand = Math.random() * cum;
                for (var i = 0; i < randomTo.length; i++) {
                    if (weights[i] >= rand) {
                        if (randomTo[i].to.startsWith("#")) {
                            let strippedTo = randomTo[i].to.substring(1);
                            goToPage(strippedTo);
                        }
                        else {
                            window.open(randomTo[i].to, "_self");
                        }
                        return;
                    }
                }

                // we should never hit this point
            }
        }


        let preloaded = {};

        async function preload(data, page) {

            // don't fetch if the current page is still loading
            var currentAssets = [...document.getElementsByClassName("link-asset")];
            while (!currentAssets.every(a => a.complete)) {

                await timeout(100);
            }

            const listen = (elem, eventName) =>
                new Promise((resolve) => elem.addEventListener(eventName, resolve));

            var listeners = [];

            //pages linked to from here
            var linkedPages = getLinkedPages(data, page);
            var assets = linkedPages.flatMap(p => getAssetsForPage(data, p));


            for (const asset of assets) {
                if (asset && preloaded[asset.id] === undefined && asset.path) {
                    preloaded[asset.id] = new Image();
                    listeners.push(listen(preloaded[asset.id], "load"));

                    if (LOCAL) {
                        preloaded[asset.id].src = "media/" + asset.path;
                    }
                    else {
                        preloaded[asset.id].src = asset.url;
                    }
                }
            }
            await Promise.allSettled(listeners);


            listeners = [];

            //pages linked to from pages that are linked to from here
            for (const nextPage of linkedPages) {
                var linkedPages = getLinkedPages(data, nextPage);
                var assets = linkedPages.flatMap(p => getAssetsForPage(data, p));

                for (const asset of assets) {
                    if (asset && preloaded[asset.id] === undefined && asset.path) {
                        preloaded[asset.id] = new Image();
                        listeners.push(listen(preloaded[asset.id], "load"));

                        if (LOCAL) {
                            preloaded[asset.id].src = "media/" + asset.path;
                        }
                        else {
                            preloaded[asset.id].src = asset.url;
                        }
                    }
                }
            }
            await Promise.allSettled(listeners);
        }

        function getLinkedPages(data, page) {
            let possiblePages = [];
            for (const link of page.links) {
                if (link.to != null && link.to.startsWith("#")) {
                    let strippedTo = link.to.substring(1);
                    let linkedPage = data.pages.find(x => x.id === strippedTo);
                    if (linkedPage) {
                        possiblePages.push(linkedPage);
                    }
                }
            }
            return possiblePages;
        }

        function getAssetsForPage(data, page) {
            let assets = [];
            for (const link of page.links) {
                assets.push(data.assets.find(a => a.id === link.image?.asset_id));
            }
            return assets;
        }

        function timeout(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        const fontPaths =
        {
            "Anybody": [{ src: 'local(Anybody), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Anybody.ttf")' }],
            "Epilogue": [
                { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue.ttf")', desc: { style: "normal" } },
                { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue-Italic2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Epilogue-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue-Italic.ttf")', desc: { style: "italic" } }
            ],
            "Gluten": [{ src: 'local(Gluten), url("https://downpour-static.b-cdn.net/fonts/woff2/Gluten.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Gluten.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Gluten.ttf")' }],
            "Handjet": [{ src: 'local(Handjet), url("https://downpour-static.b-cdn.net/fonts/woff2/Handjet.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Handjet.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Handjet.ttf")' }],
            "Hepta Slab": [{ src: 'local(Hepta Slab), url("https://downpour-static.b-cdn.net/fonts/woff2/HeptaSlab.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/HeptaSlab.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/HeptaSlab.ttf")' }],
            "Recursive": [{ src: 'local(Recursive), url("https://downpour-static.b-cdn.net/fonts/woff2/Recursive.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Recursive.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Recursive.ttf")' }],
            "Sono": [{ src: 'local(Sono), url("https://downpour-static.b-cdn.net/fonts/woff2/Sono.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Sono.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Sono.ttf")' }],
            "Source Serif": [
                { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif.ttf")', desc: { style: "normal" } },
                { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif-Italic.ttf")', desc: { style: "italic" } }
            ],
            "Public Sans": [
                { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans.ttf")', desc: { style: "normal" } },
                { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans-Italic.ttf")', desc: { style: "italic" } }
            ],
            "Nyght Serif": [
                { src: 'local(Nyght Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/NyghtVariable.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/NyghtVariable.ttf")', desc: { style: "normal" } },
                { src: 'local(Nyght Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/NyghtItalicVariable.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/NyghtItalicVariable.ttf")', desc: { style: "italic" } }
            ],
            "Shantell Sans": [
                { src: 'local(Shantell Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/ShantellSans.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/ShantellSans.ttf")', },
            ],
        };

        function loadFonts(data) {
            let fontNames = new Set();

            // collect all used fonts
            for (const page of data.pages) {
                for (const link of page.links) {
                    if (link.text != null && link.text.font != null) {
                        fontNames.add(link.text.font);
                    }
                }
            }

            //load them
            for (const fontName of fontNames) {
                if (fontPaths[fontName]) {
                    for (const def of fontPaths[fontName]) {
                        const font = new FontFace(fontName, def.src, def.desc ?? {}); //desc might specify properties, if the font face uses multiple files
                        font.load(); //we could wait on this, but we want to kick off all the loads at once - render whenever they load
                        document.fonts.add(font);
                    }
                }
            }
        }
        loadFonts(data);

        //load from hash
        if (window.location.hash && data.pages.some(p => p.id == window.location.hash.substring(1))) {
            loadPage(window.location.hash.substring(1));
        } else {
            loadPage(data.initial_page);
        }

        var queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has("p")) {
            loadPage(queryParams.get("p"));
        }
    </script>

</body>

</html>