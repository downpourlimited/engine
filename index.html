<!DOCTYPE html>
<html lang="en">

<!--
    Downpour HTML engine, for rendering Downpour games that are using v16 of the data format

License below applies to everything except the contents of the `data` variable. That belongs to the user.

MIT License

Copyright (c) 2024 Downpour Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->


<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="icon" href="https://downpour.games/favicon.ico" sizes="32x32">
    <link rel="icon" href="https://downpour.games/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="https://downpour.games/apple-touch-icon.png">

    <title>A Downpour game</title>

    <!-- social sharing section -->

    <style>
        html {
            box-sizing: border-box;
            font-size: 16px;

            text-size-adjust: none;
        }

        html,
        body {
            overflow: hidden;
        }

        body {
            min-height: 100dvh;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        p,
        ol,
        ul {
            margin: 0;
            padding: 0;
            font-weight: normal;
        }

        #page {
            position: relative;
            width: fit-content;
            transform-origin: top left;

            touch-action: manipulation;
        }

        #credits {
            position: absolute;
            bottom: 0;
            right: 0;
            left: 0;
            background-color: black;
            padding: 4px;
            font-family: 'IBM Plex Sans Condensed', 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            color: #ffffff;
            font-size: 1em;
            display: flex;
            justify-content: space-between;
            align-items: end;
            gap: 10px;
            text-align: center;
        }


        .downpour-icon,
        .downpour-icon a,
        .downpour-icon a:visited {
            height: 25px;
            width: 25px;
            color: #ffffff;
            flex-shrink: 0;
        }



        .replay-icon,
        .replay-icon a,
        .replay-icon a:visited {
            height: 21px;
            width: 21px;
            color: #ffffff;
            flex-shrink: 0;

            transition: 0.3s;
            display: inline-block;
        }

        .replay-icon:hover {
            rotate: -45deg;
        }

        #title {
            margin-left: 20px;
            margin-right: 20px;
            font-weight: bold;
            display: flex;
            gap: 8px;
            padding-bottom: 2px;
        }

        #author {
            margin-left: 4px;
            margin-right: 4px;
            padding-bottom: 2px;
        }

        #author a,
        #author a:visited {
            color: #ffffff;
            text-decoration: none;
        }

        .displayname {}

        .username {
            font-style: italic;
        }


        /*we just need this around to hold some filters for us*/
        #svg_filters {
            display: none;
        }

        .media {
            max-width: 100vw;
            max-height: 100vh;
            display: block;
        }

        .link {
            position: absolute;
            display: block;
            box-sizing: border-box;
            filter: url(#filter);
            /*overflow: hidden;*/
            text-decoration: none;

            -webkit-touch-callout: none;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;

            /* fix Safari rendering bug https://graffino.com/til/how-to-fix-filter-blur-performance-issue-in-safari */
            transform: translate3d(0, 0, 0);
        }

        .clickable {
            cursor: pointer;
        }

        .link-asset {
            width: 100%;
            height: 100%;
        }

        .link-text {
            white-space: pre-wrap;
            font-family: sans-serif;
            color: black;
            text-decoration: none;
            overflow-wrap: break-word;
        }
    </style>
</head>

<body>
    <div id="page">
    </div>

    <div id="credits">
        <div class="downpour-icon">
            <a href="https://downpour.games">
                <svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" version="1.1" viewBox="0 0 25 25" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" title="downpour.games">
                    <g>
                        <path fill="currentColor" d="m12.991 10.256v9.428c-0 8e-3 -0 0.017-1e-3 0.025-0 0-0.034 0.61 0.142 1.091 0.064 0.172 0.14 0.353 0.339 0.346 0.142-5e-3 0.251-0.03 0.331-0.088 0.122-0.089 0.161-0.24 0.191-0.402 0.055-0.297 0.042-0.638 0.039-0.953-3e-3 -0.276 0.219-0.502 0.495-0.505s0.502 0.219 0.505 0.495c4e-3 0.378 0.01 0.787-0.056 1.144-0.078 0.428-0.259 0.79-0.582 1.027-0.217 0.159-0.502 0.268-0.888 0.282-0.68 0.023-1.097-0.416-1.312-1.002-0.221-0.601-0.207-1.351-0.203-1.467l5e-3 -9.438c-1e-3 -0.034-0-0.117-0.045-0.155-0.049-0.042-0.151-0.027-0.153-0.026-0.651 0.064-1.199 0.218-1.798 0.421-0.623 0.212-1.243 0.472-1.912 0.725-0.025 0.01-0.052 0.017-0.078 0.023-0.157 0.031-0.319-0.014-0.437-0.121-1.082-0.988-2.306-0.847-3.256-0.475-1.013 0.395-1.739 1.052-1.739 1.052-0.147 0.134-0.36 0.168-0.542 0.086s-0.297-0.264-0.294-0.464c-0 0 0.044-3.142 2.33-5.642 1.459-1.596 3.833-2.948 7.72-3.008 0.109-2e-3 0.196-0.091 0.196-0.2v-0.638c-0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5v0.675c1e-3 0.089 0.072 0.161 0.161 0.162 3.908 0.053 6.292 1.409 7.756 3.009 2.286 2.5 2.33 5.642 2.33 5.642 3e-3 0.2-0.113 0.382-0.294 0.464-0.182 0.082-0.395 0.048-0.542-0.086-0-0-0.726-0.657-1.739-1.052-0.951-0.372-2.174-0.513-3.257 0.475-0.118 0.107-0.28 0.152-0.436 0.121-0.027-6e-3 -0.054-0.013-0.08-0.024-0.648-0.248-1.148-0.569-1.653-0.749-0.582-0.207-1.131-0.305-1.681-0.365l-0.344-0.031c-0.056-5e-3 -0.111 0.013-0.153 0.051-0.041 0.038-0.065 0.091-0.065 0.147zm-2.599-6.512c-2.696 0.307-4.449 1.355-5.582 2.594-1.226 1.34-1.725 2.887-1.928 3.897 0.305-0.186 0.669-0.379 1.071-0.536 0.992-0.387 2.205-0.56 3.375 0.028 0.034-1.842 0.919-4.215 3.064-5.983zm7.257 5.983c1.17-0.588 2.383-0.415 3.375-0.028 0.402 0.157 0.766 0.35 1.072 0.537-0.204-1.011-0.704-2.558-1.929-3.898-1.133-1.239-2.886-2.287-5.583-2.594 2.146 1.768 3.031 4.141 3.065 5.983zm-5.161-6.191c-0.025 0.021-0.054 0.041-0.084 0.057-2.986 1.617-4.135 4.39-4.08 6.349 0.814-0.389 2.294-0.939 4.164-0.939 2.008-0 3.394 0.507 4.165 0.898 0.038-1.957-1.115-4.703-4.08-6.308-0.031-0.016-0.059-0.036-0.085-0.057zm-6.017 9.439c1.013 1.684 1.843 2.544 1.854 4.139 0.011 1.7-1.289 2.399-2.395 2.378-1.103-0.021-2.27-0.794-2.26-2.469 5e-3 -0.817 0.238-1.433 0.623-2.076 0.339-0.567 0.807-1.159 1.327-1.981l0.433-0.685 0.418 0.694zm-0.277 1.43c-0.036-0.055-0.098-0.089-0.164-0.09-0.067-0-0.129 0.032-0.167 0.087-0.272 0.389-0.514 0.728-0.712 1.059-0.291 0.486-0.477 0.949-0.481 1.569-6e-3 0.972 0.639 1.45 1.279 1.462 0.637 0.012 1.382-0.393 1.376-1.371-6e-3 -0.8-0.278-1.37-0.671-2.005-0.14-0.227-0.295-0.46-0.46-0.711zm13.533-1.468c1.323 1.797 1.949 2.567 1.959 4.177 0.011 1.7-1.288 2.399-2.394 2.378-1.104-0.021-2.27-0.794-2.26-2.469 5e-3 -0.813 0.241-1.444 0.615-2.091 0.331-0.574 0.778-1.165 1.247-1.954l0.386-0.648 0.447 0.607zm-0.196 1.412c-0.039-0.052-0.101-0.082-0.166-0.08s-0.125 0.035-0.161 0.09c-0.259 0.388-0.495 0.733-0.691 1.072-0.286 0.496-0.477 0.975-0.481 1.599-6e-3 0.972 0.638 1.45 1.279 1.462 0.636 0.012 1.382-0.393 1.375-1.371-7e-3 -1.124-0.403-1.756-1.155-2.772z" />
                    </g>
                </svg>
            </a>
        </div>

        <div id="title">
            <div id="game-title">{{title}}</div>
            <a id="replayButton" class="replay-icon" href="?">
                <svg xmlns=" http://www.w3.org/2000/svg" viewBox="0 -960 960 960" title="Restart game">
                    <path fill="currentColor" d="M480-80q-75 0-140.5-28T225-185q-49-49-77-114.5T120-440q0-13 8.5-21.5T150-470q13 0 21.5 8.5T180-440q0 125 87.5 212.5T480-140q125 0 212.5-87.5T780-440q0-125-85-212.5T485-740h-22l52 52q9 9 9 21t-9 21q-9 9-21 9t-21-9L368-751q-9-9-9-21t9-21l106-106q8-8 20.5-8t20.5 8q8 8 8 20.5t-8 20.5l-58 58h23q75 0 140.5 28T735-695q49 49 77 114.5T840-440q0 75-28 140.5T735-185q-49 49-114.5 77T480-80Z" />
                </svg>
            </a>

        </div>

        <div id="author"><a href="/~{{author_username}}" rel="author"><span id="game-author"><span class="displayname">{{author_displayname}}</span> <span class="username">~{{author_username}}</span></span></a></div>
    </div>

    <svg id="svg_filters">
    </svg>

</body>

<script src="data.js"></script>
<script type="text/javascript">

    if (data.format_version != 16) {
        console.error(`Trying to load gameplay data with version ${data.format_version}, which is not 16`);
    }

    const LOCAL = true;

    if (LOCAL) {
        document.title = data.name ?? "";
    }

    if (data.name) {
        document.getElementById("game-title").textContent = data.name;
    }
    else if (LOCAL) {
        document.getElementById("game-title").textContent = "";
    }

    if (data.author) {
        document.getElementById("game-author").textContent = data.author;
    }
    else if (LOCAL) {
        document.getElementById("game-author").textContent = "";
    }


    let currentPageWidth = 1000;
    let currentPageHeight = 1000;


    window.addEventListener("hashchange", onHashChange, false);
    function onHashChange(event) {
        let destination = null;
        if (window.location.hash == "") {
            destination = data.initial_page;
        }
        else {
            destination = window.location.hash.substring(1);
        }

        var success = loadPage(destination);
        if (!success) {
            console.error("Page not found: " + destination);
        }
    }

    addEventListener("popstate", popstate);
    function popstate(event) {
        var queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has("p")) {
            destination = queryParams.get("p");
        }
        else {
            destination = data.initial_page;
        }

        var success = loadPage(destination);
        if (!success) {
            console.error("Page not found: " + destination);
            loadPage(data.initial_page);
        }
    }
    const replayButton = document.getElementById("replayButton");
    replayButton.addEventListener("click", (e) => {
        e.preventDefault();
        goToPage(data.initial_page);
    });


    window.addEventListener("resize", setPageScale);
    function setPageScale() {
        var htmlWidth = document.documentElement.clientWidth;
        var htmlHeight = document.documentElement.clientHeight;
        var availableHeight = htmlHeight - document.getElementById("credits").offsetHeight;
        var page_div = document.getElementById("page");
        var scale = Math.min(1, Math.min(htmlWidth / currentPageWidth, availableHeight / currentPageHeight));
        page_div.style.transform = `scale(${scale})`;
        page_div.style.left = `${(htmlWidth - currentPageWidth * scale) / 2.0}px`;
        page_div.style.top = `${(availableHeight - currentPageHeight * scale) / 2.0}px`;
    }


    // parse color, so we can manually set up the SVGs for tint rendering
    /**
     * Parse color from the string passed
     * source: https://github.com/colorjs/color-parse/blob/master/index.js
     *
     * This function MIT licensed, here it is:
            The MIT License (MIT)

            Copyright (c) 2015 Dmitry Ivanov

            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated documentation files (the "Software"), to deal
            in the Software without restriction, including without limitation the rights
            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            copies of the Software, and to permit persons to whom the Software is
            furnished to do so, subject to the following conditions:

            The above copyright notice and this permission notice shall be included in
            all copies or substantial portions of the Software.

            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
            THE SOFTWARE.
     * 
     * @return {Object} A space indicator `space`, an array `values` and `alpha`
     */
    function parseColor(cstr) {
        var m, parts = [], alpha = 1, space

        if (typeof cstr === 'string') {

            //reserved words
            if (cstr === 'transparent') {
                alpha = 0
                space = 'rgb'
                parts = [0, 0, 0]
            }

            //hex
            else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
                var base = cstr.slice(1)
                var size = base.length
                var isShort = size <= 4
                alpha = 1

                if (isShort) {
                    parts = [
                        parseInt(base[0] + base[0], 16),
                        parseInt(base[1] + base[1], 16),
                        parseInt(base[2] + base[2], 16)
                    ]
                    if (size === 4) {
                        alpha = parseInt(base[3] + base[3], 16) / 255
                    }
                }
                else {
                    parts = [
                        parseInt(base[0] + base[1], 16),
                        parseInt(base[2] + base[3], 16),
                        parseInt(base[4] + base[5], 16)
                    ]
                    if (size === 8) {
                        alpha = parseInt(base[6] + base[7], 16) / 255
                    }
                }

                if (!parts[0]) parts[0] = 0
                if (!parts[1]) parts[1] = 0
                if (!parts[2]) parts[2] = 0

                space = 'rgb'
            }

            //color space
            else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
                var name = m[1]
                var isRGB = name === 'rgb'
                var base = name.replace(/a$/, '')
                space = base
                var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3
                parts = m[2].trim()
                    .split(/\s*[,\/]\s*|\s+/)
                    .map(function (x, i) {
                        //<percentage>
                        if (/%$/.test(x)) {
                            //alpha
                            if (i === size) return parseFloat(x) / 100
                            //rgb
                            if (base === 'rgb') return parseFloat(x) * 255 / 100
                            return parseFloat(x)
                        }
                        //hue
                        else if (base[i] === 'h') {
                            //<deg>
                            if (/deg$/.test(x)) {
                                return parseFloat(x)
                            }
                            //<base-hue>
                            else if (baseHues[x] !== undefined) {
                                return baseHues[x]
                            }
                        }
                        return parseFloat(x)
                    })

                if (name === base) parts.push(1)
                alpha = (isRGB) ? 1 : (parts[size] === undefined) ? 1 : parts[size]
                parts = parts.slice(0, size)
            }

            //named channels case
            else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
                parts = cstr.match(/([0-9]+)/g).map(function (value) {
                    return parseFloat(value)
                })

                space = cstr.match(/([a-z])/ig).join('').toLowerCase()
            }
        }

        //numeric case
        else if (!isNaN(cstr)) {
            space = 'rgb'
            parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff]
        }

        //array-like
        else if (Array.isArray(cstr) || cstr.length) {
            parts = [cstr[0], cstr[1], cstr[2]]
            space = 'rgb'
            alpha = cstr.length === 4 ? cstr[3] : 1
        }

        //object case - detects css cases of rgb and hsl
        else if (cstr instanceof Object) {
            if (cstr.r != null || cstr.red != null || cstr.R != null) {
                space = 'rgb'
                parts = [
                    cstr.r || cstr.red || cstr.R || 0,
                    cstr.g || cstr.green || cstr.G || 0,
                    cstr.b || cstr.blue || cstr.B || 0
                ]
            }
            else {
                space = 'hsl'
                parts = [
                    cstr.h || cstr.hue || cstr.H || 0,
                    cstr.s || cstr.saturation || cstr.S || 0,
                    cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
                ]
            }

            alpha = cstr.a || cstr.alpha || cstr.opacity || 1

            if (cstr.opacity != null) alpha /= 100
        }

        return {
            space: space,
            values: parts,
            alpha: alpha
        }
    }
    function easeInQuad(x) {
        return x * x;
    }
    function lerp(v0, v1, t) {
        return v0 * (1 - t) + v1 * t;
    }

    /**
     * Description
     * @param {Color} color
     * @returns {void}
     */
    function makeTintFilter(parsedColor) {

        //create the filter
        var xmlns = "http://www.w3.org/2000/svg";
        var svg = document.getElementById("svg_filters");
        var filter = document.createElementNS(xmlns, "filter");
        var id = Math.random().toString(36).substr(2, 9);
        filter.id = id;
        var colorMatrix = document.createElementNS(xmlns, "feColorMatrix");
        filter.appendChild(colorMatrix);
        colorMatrix.setAttribute("type", "matrix");
        colorMatrix.setAttribute("color-interpolation-filters", "sRGB");

        //prep values from the selected color
        let r = parsedColor.values[0] / 255;
        let g = parsedColor.values[1] / 255;
        let b = parsedColor.values[2] / 255;
        let a = parsedColor.alpha;
        let lightness = (Math.max(r, Math.max(g, b)) + Math.min(r, Math.min(g, b))) / 2;
        var light = easeInQuad(lightness);
        var invLight = easeInQuad(1 - lightness);

        //it's big matrix time!
        let vals = [
            lerp(1, lerp(1.0, r, light) * 0.2989, a),
            lerp(0, lerp(1.0, r, light) * 0.5870, a),
            lerp(0, lerp(1.0, r, light) * 0.1140, a),
            0,
            a * invLight * r,
            lerp(0, lerp(1.0, g, light) * 0.2989, a),
            lerp(1, lerp(1.0, g, light) * 0.5870, a),
            lerp(0, lerp(1.0, g, light) * 0.1140, a),
            0,
            a * invLight * g,
            lerp(0, lerp(1.0, b, light) * 0.2989, a),
            lerp(0, lerp(1.0, b, light) * 0.5870, a),
            lerp(1, lerp(1.0, b, light) * 0.1140, a),
            0,
            a * invLight * b,
            0,
            0,
            0,
            1,
            0
        ];

        colorMatrix.setAttribute('values', vals.join(" "));
        svg.appendChild(filter);
        return id;
    }


    /**
     * Description
     * @param {any} link
     * @param {HTMLDivElement} link_element
     * @returns {void}
     */
    function renderLink(link, link_element) {


        //add link properties to dataset, so CSS can pick it up
        const ignored_keys = ["image", "text"]; //string representation isn't helpful, so skip it
        for (const [key, val] of Object.entries(link)) {
            if (!ignored_keys.includes(key)) {
                link_element.dataset[key] = val;
            }
        }
        if (link.type === "image") {


            //add image properties to dataset, so CSS can pick it up
            const ignored_keys = [];
            for (const [key, val] of Object.entries(link.image)) {
                if (!ignored_keys.includes(key)) {
                    link_element.dataset[key] = val;
                }
            }

            //render the image
            let asset = data.assets.find(a => a.id === link.image.asset_id);
            let media_element;

            media_element = document.createElement("img");
            media_element.classList.add("link-asset");
            media_element.draggable = false;
            if (LOCAL) {
                media_element.src = "media/" + asset.path;
            }
            else {
                media_element.src = asset.url;
            }
            link_element.appendChild(media_element);

            var filter = "";

            //set up tint magic
            let parsedColor = parseColor(link.image.bg_c);
            if (parsedColor.alpha > 0.001) {
                let tint_id = makeTintFilter(parsedColor);
                filter += ` url(#${tint_id})`;
            }

            if (link.image.blur > 0.001) {
                var smaller_axis = Math.min(link.w, link.h);
                //0.5 to match Flutter, visually
                filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
            }
            link_element.style.filter = filter;

            if (link.image.b_width > 0.001) {
                link_element.style.borderWidth = `${link.image.b_width}px`;
                link_element.style.borderStyle = "solid";
                link_element.style.borderColor = link.image.b_c;

            }

            if (link.image.b_radius > 0.001) {
                link_element.style.borderRadius = `${link.image.b_radius}px`;
                media_element.style.borderRadius = `${link.image.b_radius - (link.image.b_width ?? 0)}px`;
            }
        }
        else if (link.type === "empty") {

            //add image properties to dataset, so CSS can pick it up
            const ignored_keys = [];
            for (const [key, val] of Object.entries(link.image)) {
                if (!ignored_keys.includes(key)) {
                    link_element.dataset[key] = val;
                }
            }

            //you can only have a solid background if it's empty
            link_element.style.backgroundColor = link.image.bg_c;



            var filter = "";

            if (link.image.blur > 0.001) {
                var smaller_axis = Math.min(link.w, link.h);
                //0.5 to match Flutter, visually
                filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
            }
            link_element.style.filter = filter;


            if (link.image.b_width > 0.001) {
                link_element.style.borderWidth = `${link.image.b_width}px`;
                link_element.style.borderStyle = "solid";
                link_element.style.borderColor = link.image.b_c;
            }

            if (link.image.b_radius > 0.001) {
                link_element.style.borderRadius = `${link.image.b_radius}px`;
            }

        }
        else if (link.type === "text") {

            const text_element = document.createElement("div");
            text_element.classList.add("link-text");
            text_element.textContent = link.text.text;
            text_element.style.fontSize = `${link.text.size}px`;
            text_element.style.color = link.text.c;
            text_element.style.textAlign = link.text.h_a;

            // do vertical alignment
            link_element.style.display = "flex";
            link_element.style.flexDirection = "column";
            if (link.text.v_a === "top") {
                link_element.style.justifyContent = "start";
            }
            else if (link.text.v_a === "middle") {
                link_element.style.justifyContent = "center";
            }
            else if (link.text.v_a === "bottom") {
                link_element.style.justifyContent = "end";
            }

            //set font family. note: we loaded these fonts earlier
            text_element.style.fontFamily = link.text.font;

            //unless it has an ital (or slnt) axis, apply italics the old fashioned way
            if (!["Anybody", "Gluten", "Recursive"].includes(link.text.font)) {
                //if it's set & over 0.5, make it italic, else normal
                text_element.style.fontStyle = link.text["ital"] ?? 0 > 0.5 ? "italic" : "normal";
            }

            //font variation axes, and their defaults
            const axes = { "wght": 400, 'ital': 0, 'wdth': 100, 'opsz': 20, 'MONO': 0, 'ELSH': 2, 'CASL': 0, 'slnt': 0 };
            // use specified axis, or the default. string format like: `'ital' 0.345, 'wght' 900`
            text_element.style.fontVariationSettings = Object.keys(axes).map((a) => `'${a}' ${link.text[a] ?? axes[a]}`).join(", ");

            text_element.style.letterSpacing = `${link.text.spacing ?? 0}em`;
            text_element.style.transform = `translate(${link.text.spacing * 0.5 ?? 0}em,0px)`;


            link_element.appendChild(text_element);
        }
        else {
            console.error(`Unknown link type ${link.type}`);
        }



    }

    function loadPage(pageId) {
        document.getElementById("svg_filters").innerHTML = ""; //clear old tint filters

        var page = data.pages.find(x => x.id === pageId);
        if (!page) {
            return false;
        }

        if (page.bg_c) {
            document.body.style.background = page.bg_c;
        }

        currentPageWidth = page.width;
        currentPageHeight = page.height;

        var page_div = document.getElementById("page");
        page_div.innerHTML = "";
        page_div.style.width = `${page.width}px`;
        page_div.style.height = `${page.height}px`;

        //needed so that touch-action: manipulation; applies to non-clickable areas
        page_div.addEventListener('click', () => { })

        setPageScale();


        for (const link of page.links) {

            var link_element = document.createElement(link.to ? "a" : "div");
            if (link.to == "!random") {
                link_element.addEventListener("click", (e) => goToRandom(link, e));
                link_element.classList.add("clickable");
            }
            else if (link.to != null) {
                if (link.to.startsWith("#")) {
                    let strippedTo = link.to.substring(1);
                    link_element.href = `?p=${strippedTo}`;
                    link_element.addEventListener("click", (e) => {
                        e.preventDefault();
                        goToPage(strippedTo, e);
                    });
                }
                else {
                    link_element.href = link.to;
                }
                link_element.classList.add("clickable");
            }
            link_element.classList.add("link");
            link_element.style.left = link.x + "px";
            link_element.style.top = link.y + "px";
            link_element.style.width = link.w + "px";
            link_element.style.height = link.h + "px";
            link_element.draggable = false;

            renderLink(link, link_element);

            page_div.appendChild(link_element);
        }

        window.scrollTo(0, 0);

        // window.addEventListener('load', (event) => {
        preload(data, page);
        // });
        return true;
    }


    /**
     * Go to page
     * @param {String} to
     * @returns {void}
     * */
    function goToPage(to) {
        console.log("go to page", to);

        const url = new URL(location);
        url.searchParams.set("p", to);
        history.pushState({}, "", url);

        loadPage(to);
        // window.open(to, "_self");
    }

    function goToRandom(link, event) {
        console.log("go to random", link);


        let randomTo = link.randomTo;

        if (randomTo == null || randomTo.length == 0) {
            console.log("go to random page, but no random page options");
        }
        else {

            let cum = 0;
            let weights = [];
            for (let r of randomTo) {
                cum += r.weight ?? 1;
                weights.push(cum);
            }

            var rand = Math.random() * cum;
            for (var i = 0; i < randomTo.length; i++) {
                if (weights[i] >= rand) {
                    if (randomTo[i].to.startsWith("#")) {
                        let strippedTo = randomTo[i].to.substring(1);
                        goToPage(strippedTo);
                    }
                    else {
                        window.open(randomTo[i].to, "_self");
                    }
                    return;
                }
            }

            // we should never hit this point
        }
    }


    let preloaded = {};

    async function preload(data, page) {

        // don't fetch if the current page is still loading
        var currentAssets = [...document.getElementsByClassName("link-asset")];
        while (!currentAssets.every(a => a.complete)) {

            await timeout(100);
        }

        const listen = (elem, eventName) =>
            new Promise((resolve) => elem.addEventListener(eventName, resolve));

        var listeners = [];

        //pages linked to from here
        var linkedPages = getLinkedPages(data, page);
        var assets = linkedPages.flatMap(p => getAssetsForPage(data, p));


        for (const asset of assets) {
            if (asset && preloaded[asset.id] === undefined && asset.path) {
                preloaded[asset.id] = new Image();
                listeners.push(listen(preloaded[asset.id], "load"));

                if (LOCAL) {
                    preloaded[asset.id].src = "media/" + asset.path;
                }
                else {
                    preloaded[asset.id].src = asset.url;
                }
            }
        }
        await Promise.allSettled(listeners);


        listeners = [];

        //pages linked to from pages that are linked to from here
        for (const nextPage of linkedPages) {
            var linkedPages = getLinkedPages(data, nextPage);
            var assets = linkedPages.flatMap(p => getAssetsForPage(data, p));

            for (const asset of assets) {
                if (asset && preloaded[asset.id] === undefined && asset.path) {
                    preloaded[asset.id] = new Image();
                    listeners.push(listen(preloaded[asset.id], "load"));

                    if (LOCAL) {
                        preloaded[asset.id].src = "media/" + asset.path;
                    }
                    else {
                        preloaded[asset.id].src = asset.url;
                    }
                }
            }
        }
        await Promise.allSettled(listeners);
    }

    function getLinkedPages(data, page) {
        let possiblePages = [];
        for (const link of page.links) {
            if (link.to != null && link.to.startsWith("#")) {
                let strippedTo = link.to.substring(1);
                let linkedPage = data.pages.find(x => x.id === strippedTo);
                if (linkedPage) {
                    possiblePages.push(linkedPage);
                }
            }
        }
        return possiblePages;
    }

    function getAssetsForPage(data, page) {
        let assets = [];
        for (const link of page.links) {
            assets.push(data.assets.find(a => a.id === link.image?.asset_id));
        }
        return assets;
    }

    function timeout(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    const fontPaths =
        (LOCAL) ? {
            "Anybody": [{ src: 'local(Anybody), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Anybody.ttf")' }],
            "Epilogue": [
                { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue.ttf")', desc: { style: "normal" } },
                { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue-Italic2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Epilogue-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue-Italic.ttf")', desc: { style: "italic" } }
            ],
            "Gluten": [{ src: 'local(Gluten), url("https://downpour-static.b-cdn.net/fonts/woff2/Gluten.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Gluten.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Gluten.ttf")' }],
            "Handjet": [{ src: 'local(Handjet), url("https://downpour-static.b-cdn.net/fonts/woff2/Handjet.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Handjet.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Handjet.ttf")' }],
            "Hepta Slab": [{ src: 'local(Hepta Slab), url("https://downpour-static.b-cdn.net/fonts/woff2/HeptaSlab.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/HeptaSlab.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/HeptaSlab.ttf")' }],
            "Recursive": [{ src: 'local(Recursive), url("https://downpour-static.b-cdn.net/fonts/woff2/Recursive.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Recursive.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Recursive.ttf")' }],
            "Sono": [{ src: 'local(Sono), url("https://downpour-static.b-cdn.net/fonts/woff2/Sono.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Sono.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Sono.ttf")' }],
            "Source Serif": [
                { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif.ttf")', desc: { style: "normal" } },
                { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif-Italic.ttf")', desc: { style: "italic" } }
            ],
            "Public Sans": [
                { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans.ttf")', desc: { style: "normal" } },
                { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans-Italic.ttf")', desc: { style: "italic" } }
            ],
        } : {
            "Anybody": [{ src: 'local(Anybody), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Anybody.ttf")' }],
            "Epilogue": [
                { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue.ttf")', desc: { style: "normal" } },
                { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue-Italic2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Epilogue-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue-Italic.ttf")', desc: { style: "italic" } }
            ],
            "Gluten": [{ src: 'local(Gluten), url("https://downpour-static.b-cdn.net/fonts/woff2/Gluten.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Gluten.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Gluten.ttf")' }],
            "Handjet": [{ src: 'local(Handjet), url("https://downpour-static.b-cdn.net/fonts/woff2/Handjet.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Handjet.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Handjet.ttf")' }],
            "Hepta Slab": [{ src: 'local(Hepta Slab), url("https://downpour-static.b-cdn.net/fonts/woff2/HeptaSlab.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/HeptaSlab.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/HeptaSlab.ttf")' }],
            "Recursive": [{ src: 'local(Recursive), url("https://downpour-static.b-cdn.net/fonts/woff2/Recursive.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Recursive.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Recursive.ttf")' }],
            "Sono": [{ src: 'local(Sono), url("https://downpour-static.b-cdn.net/fonts/woff2/Sono.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Sono.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Sono.ttf")' }],
            "Source Serif": [
                { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif.ttf")', desc: { style: "normal" } },
                { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif-Italic.ttf")', desc: { style: "italic" } }
            ],
            "Public Sans": [
                { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans.ttf")', desc: { style: "normal" } },
                { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans-Italic.ttf")', desc: { style: "italic" } }
            ],
        };

    function loadFonts(data) {
        let fontNames = new Set();

        // collect all used fonts
        for (const page of data.pages) {
            for (const link of page.links) {
                if (link.text != null && link.text.font != null) {
                    fontNames.add(link.text.font);
                }
            }
        }

        //load them
        for (const fontName of fontNames) {
            if (fontPaths[fontName]) {
                for (const def of fontPaths[fontName]) {
                    const font = new FontFace(fontName, def.src, def.desc ?? {}); //desc might specify properties, if the font face uses multiple files
                    font.load(); //we could wait on this, but we want to kick off all the loads at once - render whenever they load
                    document.fonts.add(font);
                }
            }
        }
    }
    loadFonts(data);

    //load from hash
    if (window.location.hash && data.pages.some(p => p.id == window.location.hash.substring(1))) {
        loadPage(window.location.hash.substring(1));
    } else {
        loadPage(data.initial_page);
    }

    var queryParams = new URLSearchParams(window.location.search);
    if (queryParams.has("p")) {
        loadPage(queryParams.get("p"));
    }
</script>

</html>