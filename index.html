<!DOCTYPE html>
<html lang="en">

<!--
    Downpour HTML engine, for rendering Downpour games that are using v18 of the data format

License below applies to everything except the contents of the `data` variable. That belongs to the user.

MIT License

Copyright (c) 2024 Downpour Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->


<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" href="https://downpour.games/favicon.ico" sizes="32x32">
    <link rel="icon" href="https://downpour.games/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="https://downpour.games/apple-touch-icon.png">

    <title>A Downpour game</title>

    <!-- social sharing section -->

    <style>
        html {
            box-sizing: border-box;
            font-size: 16px;

            text-size-adjust: none;
        }

        html,
        body {
            overflow: hidden;
        }

        body {
            display: flex;
            height: 100dvh;
            flex-direction: column;
            justify-content: end;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        p,
        ol,
        ul {
            margin: 0;
            padding: 0;
            font-weight: normal;
        }

        #page_wrapper {
            width: 100%;
            /* grow or shrink as necessary to fill the page */
            flex: 1 1;
            /* ignore height from child page when calculating flex size */
            height: 0;
            /* allow mute button to be absolutely positioned within */
            position: relative;
        }

        #page {
            flex: auto;
            transform-origin: top left;

            touch-action: manipulation;
        }

        #credits {
            background-color: black;
            padding: 4px;
            font-family: 'IBM Plex Sans Condensed', 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            color: #ffffff;
            font-size: 1em;
            display: flex;
            justify-content: space-between;
            align-items: end;
            gap: 10px;
            text-align: center;
            align-items: center;
        }


        .downpour-icon,
        .downpour-icon a,
        .downpour-icon a:visited {
            color: #ffffff;
            flex-shrink: 0;

            text-decoration: none;

            gap: 8px;
            /*padding-bottom: 2px;*/
            display: flex;
            align-items: center;
        }

        .downpour-icon svg {

            height: 25px;
            width: 25px;
        }


        .replay-icon,
        .replay-icon a,
        .replay-icon a:visited {
            height: 21px;
            width: 21px;
            color: #ffffff;
            flex-shrink: 0;

            transition: 0.3s;
            display: inline-block;
        }

        .replay-icon:hover {
            rotate: -45deg;
        }

        #title {
            margin-left: 20px;
            margin-right: 20px;
            font-weight: bold;
            display: flex;
            gap: 8px;
            padding-bottom: 2px;

            align-items: center;
        }

        #author {
            margin-left: 4px;
            margin-right: 4px;
            padding-bottom: 2px;
        }

        #author a,
        #author a:visited {
            color: #ffffff;
            text-decoration: none;
        }

        .username {
            font-style: italic;
        }

        /*we just need this around to hold some filters for us. can't display:none as that stops it working on FF*/
        #svg_filters {
            position: absolute;
            height: 0;
        }

        .media {
            max-width: 100vw;
            max-height: 100vh;
            display: block;
        }

        .link {
            position: absolute;
            display: block;
            box-sizing: border-box;
            filter: url(#filter);
            /*overflow: hidden;*/
            text-decoration: none;

            -webkit-touch-callout: none;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;

            /* fix Safari rendering bug https://graffino.com/til/how-to-fix-filter-blur-performance-issue-in-safari */
            transform: translate3d(0, 0, 0);
        }

        .clickable {
            cursor: pointer;
        }

        .link-asset {
            width: 100%;
            height: 100%;
        }

        .link-text {
            white-space: pre-wrap;
            font-family: sans-serif;
            color: black;
            text-decoration: none;
            overflow-wrap: break-word;
        }

        iframe {
            border-width: 0;
            border-radius: 4px;
        }

        .comment-placeholder {
            font-family: 'IBM Plex Sans Condensed', 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            font-style: italic;
            text-align: center;
            border-radius: 4px;
            background-color: #F0F0FF;
            color: #353783;
            display: grid;
            align-items: center;
            height: 100%;
            padding: 5%;

        }

        .link-with-error {

            background-color: #fff0f0;
            color: #833535;
        }

        .link-error {

            font-family: 'IBM Plex Sans Condensed', 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            text-align: center;
            height: 100%;
            padding: 5%;
            border-radius: inherit;

        }

        #mute_button {
            position: absolute;
            right: 1em;
            bottom: 1em;
            width: 3em;
            height: 3em;
            border-radius: 1.5em;
            border: 0;
            opacity: .3;
        }

        #mute_button>*,
        #mute_button svg {

            width: 100%;
            height: 100%;
        }

        .visually_hidden {
            clip: rect(0 0 0 0);
            clip-path: inset(50%);
            height: 1px;
            overflow: hidden;
            position: absolute;
            white-space: nowrap;
            width: 1px;
        }
    </style>
</head>

<body>
    <div id="page_wrapper">
        <div id="page">
        </div>

        <div>
            <button id="mute_button" hidden>
                <div id="mute_icon">
                    <svg viewBox="0 0 246 246">
                        <path d="M87.077,175.875c-0.358,-0.212 -0.582,-0.596 -0.589,-1.012c-0.007,-0.417 0.203,-0.808 0.554,-1.032l45.999,-29.383c0.383,-0.244 0.87,-0.252 1.26,-0.02c0.39,0.232 0.616,0.665 0.583,1.117c-2.235,33.233 -8.128,47.452 -8.128,47.452c-0.522,1.28 -1.576,2.27 -2.887,2.711c-1.311,0.442 -2.749,0.291 -3.939,-0.413l-32.853,-19.42Z" />
                        <path d="M38.882,148.141c-0.347,0.221 -0.784,0.25 -1.157,0.074c-0.373,-0.175 -0.63,-0.53 -0.68,-0.939c-0.988,-8.088 -2.345,-20.58 -2.345,-28.215c0,-12.007 3.357,-36.023 3.357,-36.023c0.329,-2.345 2.333,-4.09 4.701,-4.096l16.143,-0.036l63.854,-36.149c1.274,-0.721 2.809,-0.816 4.162,-0.256c1.354,0.56 2.373,1.712 2.765,3.122c0,0 3.439,12.228 5.129,40.51c0.027,0.435 -0.184,0.85 -0.551,1.084l-95.378,60.924Z" />
                        <path d="M167.127,123.232c0.033,-0.371 0.236,-0.706 0.549,-0.907c1.911,-1.22 8.812,-5.629 12.095,-7.726c0.365,-0.233 0.826,-0.251 1.208,-0.049c0.383,0.203 0.626,0.595 0.638,1.028c0.019,0.702 0.029,1.408 0.029,2.115c-0,20.773 -8.358,39.61 -21.892,53.327c-2.766,2.804 -7.288,2.834 -10.092,0.068c-2.804,-2.766 -2.834,-7.288 -0.068,-10.092c9.774,-9.906 16.225,-23.1 17.533,-37.764Z" />
                        <path d="M152.451,75.598c-0.291,0.186 -0.647,0.237 -0.979,0.142c-0.331,-0.096 -0.606,-0.329 -0.753,-0.641c-1.28,-2.793 -0.662,-6.212 1.754,-8.353c2.948,-2.613 7.462,-2.341 10.074,0.607l0.086,0.097c0.232,0.263 0.338,0.614 0.289,0.961c-0.049,0.347 -0.247,0.656 -0.542,0.845l-9.929,6.342Z" />
                        <path d="M209.797,95.42c0.338,-0.216 0.76,-0.249 1.127,-0.089c0.366,0.16 0.629,0.493 0.7,0.886c1.192,6.708 1.815,13.613 1.815,20.661c-0,32.12 -12.923,61.245 -33.85,82.455c-2.766,2.803 -7.288,2.834 -10.092,0.067c-2.804,-2.766 -2.834,-7.288 -0.068,-10.092c18.383,-18.631 29.737,-44.215 29.737,-72.43c0,-4.768 -0.324,-9.462 -0.952,-14.059l11.583,-7.399Z" />
                        <path d="M191.8,48.972c0.189,0.268 0.261,0.602 0.198,0.924c-0.063,0.322 -0.255,0.604 -0.532,0.78l-10.019,6.401c-0.538,0.343 -1.251,0.206 -1.622,-0.313c-2.059,-2.865 -4.262,-5.62 -6.597,-8.254c-2.612,-2.948 -2.34,-7.462 0.607,-10.074c2.948,-2.613 7.462,-2.341 10.074,0.607c2.803,3.162 5.438,6.477 7.891,9.929Z" />
                        <path d="M30.792,192.825c-4.425,2.827 -10.313,1.529 -13.14,-2.897c-2.827,-4.426 -1.529,-10.314 2.896,-13.141l194.42,-124.186c4.425,-2.827 10.313,-1.529 13.14,2.896c2.827,4.426 1.529,10.314 -2.896,13.141l-194.42,124.187Z" />
                    </svg>
                    <span class="visually_hidden">Mute</span>
                </div>
                <div id="unmute_icon" hidden>
                    <svg viewBox="0 0 246 246" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;">
                        <g id="unmuted">
                            <path d="M42.768,83.7c0,-0 -3.31,23.574 -3.31,35.361c-0,11.789 3.31,35.375 3.31,35.375l17.391,-0l0,-70.775l-17.391,0.039Z" style="stroke:#000;stroke-width:9.52px;" />
                            <path d="M60.159,83.661l64.94,-36.764c-0,0 5.871,21.132 5.871,72.151c0,51.02 -8.619,72.152 -8.619,72.152l-62.192,-36.764" style="stroke:#000;stroke-width:9.52px;" />
                            <path d="M157.207,72.086c10.764,12.145 17.302,28.119 17.302,45.607c0,18.821 -7.573,35.887 -19.835,48.315" style="fill:none;stroke:#000;stroke-width:14.27px;" />
                            <path d="M178.569,43.776c17.253,19.467 27.733,45.07 27.733,73.102c0,30.168 -12.138,57.522 -31.793,77.443" style="fill:none;stroke:#000;stroke-width:14.27px;" />
                        </g>
                    </svg>

                    <span class="visually_hidden">Unmute</span>
                </div>
            </button>
        </div>
    </div>

    <div id="credits">
        <div class="downpour-icon">
            <a href="https://downpour.games">
                <svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" version="1.1" viewBox="0 0 25 25" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" title="downpour.games">
                    <g>
                        <path fill="currentColor" d="m12.991 10.256v9.428c-0 8e-3 -0 0.017-1e-3 0.025-0 0-0.034 0.61 0.142 1.091 0.064 0.172 0.14 0.353 0.339 0.346 0.142-5e-3 0.251-0.03 0.331-0.088 0.122-0.089 0.161-0.24 0.191-0.402 0.055-0.297 0.042-0.638 0.039-0.953-3e-3 -0.276 0.219-0.502 0.495-0.505s0.502 0.219 0.505 0.495c4e-3 0.378 0.01 0.787-0.056 1.144-0.078 0.428-0.259 0.79-0.582 1.027-0.217 0.159-0.502 0.268-0.888 0.282-0.68 0.023-1.097-0.416-1.312-1.002-0.221-0.601-0.207-1.351-0.203-1.467l5e-3 -9.438c-1e-3 -0.034-0-0.117-0.045-0.155-0.049-0.042-0.151-0.027-0.153-0.026-0.651 0.064-1.199 0.218-1.798 0.421-0.623 0.212-1.243 0.472-1.912 0.725-0.025 0.01-0.052 0.017-0.078 0.023-0.157 0.031-0.319-0.014-0.437-0.121-1.082-0.988-2.306-0.847-3.256-0.475-1.013 0.395-1.739 1.052-1.739 1.052-0.147 0.134-0.36 0.168-0.542 0.086s-0.297-0.264-0.294-0.464c-0 0 0.044-3.142 2.33-5.642 1.459-1.596 3.833-2.948 7.72-3.008 0.109-2e-3 0.196-0.091 0.196-0.2v-0.638c-0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5v0.675c1e-3 0.089 0.072 0.161 0.161 0.162 3.908 0.053 6.292 1.409 7.756 3.009 2.286 2.5 2.33 5.642 2.33 5.642 3e-3 0.2-0.113 0.382-0.294 0.464-0.182 0.082-0.395 0.048-0.542-0.086-0-0-0.726-0.657-1.739-1.052-0.951-0.372-2.174-0.513-3.257 0.475-0.118 0.107-0.28 0.152-0.436 0.121-0.027-6e-3 -0.054-0.013-0.08-0.024-0.648-0.248-1.148-0.569-1.653-0.749-0.582-0.207-1.131-0.305-1.681-0.365l-0.344-0.031c-0.056-5e-3 -0.111 0.013-0.153 0.051-0.041 0.038-0.065 0.091-0.065 0.147zm-2.599-6.512c-2.696 0.307-4.449 1.355-5.582 2.594-1.226 1.34-1.725 2.887-1.928 3.897 0.305-0.186 0.669-0.379 1.071-0.536 0.992-0.387 2.205-0.56 3.375 0.028 0.034-1.842 0.919-4.215 3.064-5.983zm7.257 5.983c1.17-0.588 2.383-0.415 3.375-0.028 0.402 0.157 0.766 0.35 1.072 0.537-0.204-1.011-0.704-2.558-1.929-3.898-1.133-1.239-2.886-2.287-5.583-2.594 2.146 1.768 3.031 4.141 3.065 5.983zm-5.161-6.191c-0.025 0.021-0.054 0.041-0.084 0.057-2.986 1.617-4.135 4.39-4.08 6.349 0.814-0.389 2.294-0.939 4.164-0.939 2.008-0 3.394 0.507 4.165 0.898 0.038-1.957-1.115-4.703-4.08-6.308-0.031-0.016-0.059-0.036-0.085-0.057zm-6.017 9.439c1.013 1.684 1.843 2.544 1.854 4.139 0.011 1.7-1.289 2.399-2.395 2.378-1.103-0.021-2.27-0.794-2.26-2.469 5e-3 -0.817 0.238-1.433 0.623-2.076 0.339-0.567 0.807-1.159 1.327-1.981l0.433-0.685 0.418 0.694zm-0.277 1.43c-0.036-0.055-0.098-0.089-0.164-0.09-0.067-0-0.129 0.032-0.167 0.087-0.272 0.389-0.514 0.728-0.712 1.059-0.291 0.486-0.477 0.949-0.481 1.569-6e-3 0.972 0.639 1.45 1.279 1.462 0.637 0.012 1.382-0.393 1.376-1.371-6e-3 -0.8-0.278-1.37-0.671-2.005-0.14-0.227-0.295-0.46-0.46-0.711zm13.533-1.468c1.323 1.797 1.949 2.567 1.959 4.177 0.011 1.7-1.288 2.399-2.394 2.378-1.104-0.021-2.27-0.794-2.26-2.469 5e-3 -0.813 0.241-1.444 0.615-2.091 0.331-0.574 0.778-1.165 1.247-1.954l0.386-0.648 0.447 0.607zm-0.196 1.412c-0.039-0.052-0.101-0.082-0.166-0.08s-0.125 0.035-0.161 0.09c-0.259 0.388-0.495 0.733-0.691 1.072-0.286 0.496-0.477 0.975-0.481 1.599-6e-3 0.972 0.638 1.45 1.279 1.462 0.636 0.012 1.382-0.393 1.375-1.371-7e-3 -1.124-0.403-1.756-1.155-2.772z" />
                    </g>
                </svg>
                <span class="visually_hidden">downpour.games</span>
            </a>
        </div>

        <div id="title">
            <div id="game-title">{{title}}</div>
            <a id="replayButton" class="replay-icon" href="?">
                <svg xmlns=" http://www.w3.org/2000/svg" viewBox="0 -960 960 960" title="Restart game">
                    <path fill="currentColor" d="M480-80q-75 0-140.5-28T225-185q-49-49-77-114.5T120-440q0-13 8.5-21.5T150-470q13 0 21.5 8.5T180-440q0 125 87.5 212.5T480-140q125 0 212.5-87.5T780-440q0-125-85-212.5T485-740h-22l52 52q9 9 9 21t-9 21q-9 9-21 9t-21-9L368-751q-9-9-9-21t9-21l106-106q8-8 20.5-8t20.5 8q8 8 8 20.5t-8 20.5l-58 58h23q75 0 140.5 28T735-695q49 49 77 114.5T840-440q0 75-28 140.5T735-185q-49 49-114.5 77T480-80Z" />
                </svg>
                <span class="visually_hidden">Replay</span>
            </a>

        </div>

        <div id="author"><a href="/~{{author_username}}" rel="author"><span id="game-author"><span class="displayname">{{author_displayname}}</span> <span class="username">~{{author_username}}</span></span></a></div>

    </div>

    <svg id="svg_filters">
    </svg>

</body>

<script src="data.js"></script>
<script type="text/javascript">

    if (data.format_version != 18) {
        console.error(`Trying to load gameplay data with version ${data.format_version}, which is not 18`);
    }

    const LOCAL = true;

    if (LOCAL) {
        document.title = data.name ?? "";
    }

    if (data.name) {
        document.getElementById("game-title").textContent = data.name;
    }
    else if (LOCAL) {
        document.getElementById("game-title").textContent = "";
    }

    if (data.author) {
        document.getElementById("game-author").textContent = data.author;
    }
    else if (LOCAL) {
        document.getElementById("game-author").textContent = "";
    }


    let currentPageWidth = 1000;
    let currentPageHeight = 1000;


    window.addEventListener("hashchange", onHashChange, false);
    function onHashChange(event) {
        let destination = null;
        if (window.location.hash == "") {
            destination = data.initial_page;
        }
        else {
            destination = window.location.hash.substring(1);
        }

        var success = loadPage(destination);
        if (!success) {
            console.error("Page not found: " + destination);
        }
    }

    addEventListener("popstate", popstate);
    function popstate(event) {
        var queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has("p")) {
            destination = queryParams.get("p");
        }
        else {
            destination = data.initial_page;
        }

        var success = loadPage(destination);
        if (!success) {
            console.error("Page not found: " + destination);
            loadPage(data.initial_page);
        }
    }
    const replayButton = document.getElementById("replayButton");
    replayButton.addEventListener("click", (e) => {
        e.preventDefault();
        goToPage(data.initial_page);
    });


    window.addEventListener("resize", setPageScale);
    window.addEventListener("scroll", setPageScale); //to deal with dynamic viewport size
    function setPageScale() {
        var page_wrapper_div = document.getElementById("page_wrapper");
        var page_div = document.getElementById("page");
        var scale = Math.min(1, Math.min(page_wrapper_div.offsetWidth / page_div.offsetWidth, page_wrapper_div.offsetHeight / page_div.offsetHeight));
        page_div.style.scale = `${scale}`;
        page_div.style.translate = `${(page_wrapper_div.offsetWidth - page_div.offsetWidth * scale) / 2.0}px ${(page_wrapper_div.offsetHeight - page_div.offsetHeight * scale) / 2.0}px`;
    }


    const muteButton = document.getElementById("mute_button");
    let muted = true;
    let muteable_links_shown = false;
    muteButton.addEventListener("click", (ev) => {
        muted = !muted;

        for (const video of document.querySelectorAll("video")) {
            video.muted = muted;
        }

        showMuteButton(muted);
    });


    // TODO: can we replace this with https://gist.github.com/binarymax/0c12f01056c1ab947216c7d49ba58d72 ?

    // parse color, so we can manually set up the SVGs for tint rendering
    /**
     * Parse color from the string passed
     * source: https://github.com/colorjs/color-parse/blob/master/index.js
     *
     * This function MIT licensed, here it is:
            The MIT License (MIT)

            Copyright (c) 2015 Dmitry Ivanov

            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated documentation files (the "Software"), to deal
            in the Software without restriction, including without limitation the rights
            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            copies of the Software, and to permit persons to whom the Software is
            furnished to do so, subject to the following conditions:

            The above copyright notice and this permission notice shall be included in
            all copies or substantial portions of the Software.

            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
            THE SOFTWARE.
     * 
     * @return {Object} A space indicator `space`, an array `values` and `alpha`
     */
    function parseColor(cstr) {
        var m, parts = [], alpha = 1, space

        if (typeof cstr === 'string') {

            //reserved words
            if (cstr === 'transparent') {
                alpha = 0
                space = 'rgb'
                parts = [0, 0, 0]
            }

            //hex
            else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
                var base = cstr.slice(1)
                var size = base.length
                var isShort = size <= 4
                alpha = 1

                if (isShort) {
                    parts = [
                        parseInt(base[0] + base[0], 16),
                        parseInt(base[1] + base[1], 16),
                        parseInt(base[2] + base[2], 16)
                    ]
                    if (size === 4) {
                        alpha = parseInt(base[3] + base[3], 16) / 255
                    }
                }
                else {
                    parts = [
                        parseInt(base[0] + base[1], 16),
                        parseInt(base[2] + base[3], 16),
                        parseInt(base[4] + base[5], 16)
                    ]
                    if (size === 8) {
                        alpha = parseInt(base[6] + base[7], 16) / 255
                    }
                }

                if (!parts[0]) parts[0] = 0
                if (!parts[1]) parts[1] = 0
                if (!parts[2]) parts[2] = 0

                space = 'rgb'
            }

            //color space
            else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
                var name = m[1]
                var isRGB = name === 'rgb'
                var base = name.replace(/a$/, '')
                space = base
                var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3
                parts = m[2].trim()
                    .split(/\s*[,\/]\s*|\s+/)
                    .map(function (x, i) {
                        //<percentage>
                        if (/%$/.test(x)) {
                            //alpha
                            if (i === size) return parseFloat(x) / 100
                            //rgb
                            if (base === 'rgb') return parseFloat(x) * 255 / 100
                            return parseFloat(x)
                        }
                        //hue
                        else if (base[i] === 'h') {
                            //<deg>
                            if (/deg$/.test(x)) {
                                return parseFloat(x)
                            }
                            //<base-hue>
                            else if (baseHues[x] !== undefined) {
                                return baseHues[x]
                            }
                        }
                        return parseFloat(x)
                    })

                if (name === base) parts.push(1)
                alpha = (isRGB) ? 1 : (parts[size] === undefined) ? 1 : parts[size]
                parts = parts.slice(0, size)
            }

            //named channels case
            else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
                parts = cstr.match(/([0-9]+)/g).map(function (value) {
                    return parseFloat(value)
                })

                space = cstr.match(/([a-z])/ig).join('').toLowerCase()
            }
        }

        //numeric case
        else if (!isNaN(cstr)) {
            space = 'rgb'
            parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff]
        }

        //array-like
        else if (Array.isArray(cstr) || cstr.length) {
            parts = [cstr[0], cstr[1], cstr[2]]
            space = 'rgb'
            alpha = cstr.length === 4 ? cstr[3] : 1
        }

        //object case - detects css cases of rgb and hsl
        else if (cstr instanceof Object) {
            if (cstr.r != null || cstr.red != null || cstr.R != null) {
                space = 'rgb'
                parts = [
                    cstr.r || cstr.red || cstr.R || 0,
                    cstr.g || cstr.green || cstr.G || 0,
                    cstr.b || cstr.blue || cstr.B || 0
                ]
            }
            else {
                space = 'hsl'
                parts = [
                    cstr.h || cstr.hue || cstr.H || 0,
                    cstr.s || cstr.saturation || cstr.S || 0,
                    cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
                ]
            }

            alpha = cstr.a || cstr.alpha || cstr.opacity || 1

            if (cstr.opacity != null) alpha /= 100
        }

        return {
            space: space,
            values: parts,
            alpha: alpha
        }
    }
    function easeInQuad(x) {
        return x * x;
    }
    function lerp(v0, v1, t) {
        return v0 * (1 - t) + v1 * t;
    }

    /**
     * Description
     * @param {Color} color
     * @returns {void}
     */
    function makeTintFilter(parsedColor) {

        //create the filter
        var xmlns = "http://www.w3.org/2000/svg";
        var svg = document.getElementById("svg_filters");
        var filter = document.createElementNS(xmlns, "filter");
        var id = Math.random().toString(36).substr(2, 9);
        filter.id = id;
        var colorMatrix = document.createElementNS(xmlns, "feColorMatrix");
        filter.appendChild(colorMatrix);
        colorMatrix.setAttribute("type", "matrix");
        colorMatrix.setAttribute("color-interpolation-filters", "sRGB");

        //prep values from the selected color
        let r = parsedColor.values[0] / 255;
        let g = parsedColor.values[1] / 255;
        let b = parsedColor.values[2] / 255;
        let a = parsedColor.alpha;
        let lightness = (Math.max(r, Math.max(g, b)) + Math.min(r, Math.min(g, b))) / 2;
        var light = easeInQuad(lightness);
        var invLight = easeInQuad(1 - lightness);

        //it's big matrix time!
        let vals = [
            lerp(1, lerp(1.0, r, light) * 0.2989, a),
            lerp(0, lerp(1.0, r, light) * 0.5870, a),
            lerp(0, lerp(1.0, r, light) * 0.1140, a),
            0,
            a * invLight * r,
            lerp(0, lerp(1.0, g, light) * 0.2989, a),
            lerp(1, lerp(1.0, g, light) * 0.5870, a),
            lerp(0, lerp(1.0, g, light) * 0.1140, a),
            0,
            a * invLight * g,
            lerp(0, lerp(1.0, b, light) * 0.2989, a),
            lerp(0, lerp(1.0, b, light) * 0.5870, a),
            lerp(1, lerp(1.0, b, light) * 0.1140, a),
            0,
            a * invLight * b,
            0,
            0,
            0,
            1,
            0
        ];

        colorMatrix.setAttribute('values', vals.join(" "));
        svg.appendChild(filter);
        return id;
    }


    /**
     * Description
     * @param {any} link
     * @param {HTMLDivElement} link_element
     * @returns {void}
     */
    function renderLink(link, link_element) {


        //add link properties to dataset, so CSS can pick it up
        const ignored_keys = ["image", "text"]; //string representation isn't helpful, so skip it
        for (const [key, val] of Object.entries(link)) {
            if (!ignored_keys.includes(key)) {
                link_element.dataset[key] = val;
            }
        }
        if (link.type === "image") {


            //add image properties to dataset, so CSS can pick it up
            const ignored_keys = [];
            for (const [key, val] of Object.entries(link.image)) {
                if (!ignored_keys.includes(key)) {
                    link_element.dataset[key] = val;
                }
            }

            //render the image
            let asset = data.assets.find(a => a.id === link.image.asset_id);
            let media_element;

            media_element = document.createElement("img");
            media_element.classList.add("link-asset");
            media_element.draggable = false;
            if (LOCAL) {
                media_element.src = "media/" + asset.path;
            }
            else {
                media_element.src = asset.url;
            }
            link_element.appendChild(media_element);

            var filter = "";

            //set up tint magic
            let parsedColor = parseColor(link.image.bg_c);
            if (parsedColor.alpha > 0.001) {
                let tint_id = makeTintFilter(parsedColor);
                filter += ` url(#${tint_id})`;
            }

            if (link.image.blur > 0.001) {
                var smaller_axis = Math.min(link.w, link.h);
                //0.5 to match Flutter, visually
                filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
            }
            link_element.style.filter = filter;

            if (link.image.b_width > 0.001) {
                link_element.style.borderWidth = `${link.image.b_width}px`;
                link_element.style.borderStyle = "solid";
                link_element.style.borderColor = link.image.b_c;

            }

            if (link.image.b_radius > 0.001) {
                link_element.style.borderRadius = `${link.image.b_radius}px`;
                media_element.style.borderRadius = `${link.image.b_radius - (link.image.b_width ?? 0)}px`;
            }
        }
        else if (link.type === "video") {

            //add image properties to dataset, so CSS can pick it up
            const ignored_keys = [];
            for (const [key, val] of Object.entries(link.image)) {
                if (!ignored_keys.includes(key)) {
                    link_element.dataset[key] = val;
                }
            }

            //render the video
            let asset = data.assets.find(a => a.id === link.image.asset_id);

            let loop_setting = link.video.repeat; // "loop", "once" or "goTo"
            let volume_setting = link.video.volume; // 0 - 1
            let speed_setting = link.video.speed; // 0.1 - 4

            let media_element = document.createElement("video");
            media_element.autoplay = true;
            media_element.controls = false;
            media_element.crossOrigin = "anonymous";
            media_element.loop = loop_setting == "loop";
            media_element.volume = volume_setting;
            media_element.playbackRate = speed_setting;
            media_element.muted = muted;
            media_element.playsInline = true;

            if (volume_setting > 0) {
                muteable_links_shown = true;
            }

            if (loop_setting == "goTo") {
                media_element.addEventListener("ended", (e) => {
                    var auto_to_setting = link.video.auto_to;
                    if (auto_to_setting.startsWith("#")) {
                        let stripped_to = link.video.auto_to.substring(1);

                        goToPage(stripped_to, e);
                    }
                    else if (auto_to_setting == "!random") {
                        goToRandom(link.video.auto_random_to, e);
                    }
                    else if (!auto_to_setting.startsWith("!"))
                        window.location = auto_to_setting;
                });
            }

            media_element.classList.add("link-asset");
            media_element.draggable = false;
            if (LOCAL) {
                media_element.src = "media/" + asset.path;
            }
            else {
                media_element.src = asset.url;
            }
            //unlike images, videos won't load over a file url. so we want to show an error instead
            if (URL.parse(media_element.src).protocol != "file:") {
                link_element.appendChild(media_element);


                var filter = "";

                //we don't want to tint or blur the error message
                let parsedColor = parseColor(link.image.bg_c);
                if (parsedColor.alpha > 0.001) {
                    let tint_id = makeTintFilter(parsedColor);
                    filter += ` url(#${tint_id})`;
                }

                if (link.image.blur > 0.001) {
                    var smaller_axis = Math.min(link.w, link.h);
                    //0.5 to match Flutter, visually
                    filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
                }
                link_element.style.filter = filter;

            }
            else {
                let error_element = document.createElement("div");
                error_element.innerText = "Error: Video cannot be displayed when running Downpour games from the file system. It'll work when you put the game online, though.";
                error_element.classList.add("link-error");
                link_element.classList.add("link-with-error");
                link_element.appendChild(error_element);
            }

            // we want to show the border and border radius no matter if we're displaying the video or an error message
            if (link.image.b_width > 0.001) {
                link_element.style.borderWidth = `${link.image.b_width}px`;
                link_element.style.borderStyle = "solid";
                link_element.style.borderColor = link.image.b_c;

            }

            if (link.image.b_radius > 0.001) {
                link_element.style.borderRadius = `${link.image.b_radius}px`;
                media_element.style.borderRadius = `${link.image.b_radius - (link.image.b_width ?? 0)}px`;
            }

        }
        else if (link.type === "empty") {

            //add image properties to dataset, so CSS can pick it up
            const ignored_keys = [];
            for (const [key, val] of Object.entries(link.image)) {
                if (!ignored_keys.includes(key)) {
                    link_element.dataset[key] = val;
                }
            }

            link_element.style.backgroundColor = link.image.bg_c;


            var filter = "";

            if (link.image.blur > 0.001) {
                var smaller_axis = Math.min(link.w, link.h);
                //0.5 to match Flutter, visually
                filter += ` blur(${smaller_axis * link.image.blur * 0.5}px)`;
            }
            link_element.style.filter = filter;


            if (link.image.b_width > 0.001) {
                link_element.style.borderWidth = `${link.image.b_width}px`;
                link_element.style.borderStyle = "solid";
                link_element.style.borderColor = link.image.b_c;
            }

            if (link.image.b_radius > 0.001) {
                link_element.style.borderRadius = `${link.image.b_radius}px`;
            }

        }
        else if (link.type === "text") {

            const text_element = document.createElement("div");
            text_element.classList.add("link-text");
            text_element.textContent = link.text.text;
            text_element.style.fontSize = `${link.text.size}px`;
            text_element.style.color = link.text.c;
            text_element.style.textAlign = link.text.h_a;

            // do vertical alignment
            link_element.style.display = "flex";
            link_element.style.flexDirection = "column";
            if (link.text.v_a === "top") {
                link_element.style.justifyContent = "start";
            }
            else if (link.text.v_a === "middle") {
                link_element.style.justifyContent = "center";
            }
            else if (link.text.v_a === "bottom") {
                link_element.style.justifyContent = "end";
            }

            //set font family. note: we loaded these fonts earlier
            text_element.style.fontFamily = link.text.font;

            //unless it has an ital (or slnt) axis, apply italics the old fashioned way
            if (!["Anybody", "Gluten", "Recursive"].includes(link.text.font)) {
                //if it's set & over 0.5, make it italic, else normal
                text_element.style.fontStyle = link.text["ital"] ?? 0 > 0.5 ? "italic" : "normal";
            }

            //font variation axes, and their defaults
            const axes = { "wght": 400, 'ital': 0, 'wdth': 100, 'opsz': 20, 'MONO': 0, 'ELSH': 2, 'CASL': 0, 'slnt': 0, 'INFM': 0, 'BNCE': 0 };
            // use specified axis, or the default. string format like: `'ital' 0.345, 'wght' 900`
            text_element.style.fontVariationSettings = Object.keys(axes).map((a) => `'${a}' ${link.text[a] ?? axes[a]}`).join(", ");

            text_element.style.letterSpacing = `${link.text.spacing ?? 0}em`;
            text_element.style.transform = `translate(${link.text.spacing * 0.5 ?? 0}em,0px)`;


            let shadows = [];
            let drawGlowShadow = (link.text.s1_r > 0 && parseColor(link.text.s1_c).alpha > 0);
            let drawDropShadow = (link.text.s2_d > 0 && parseColor(link.text.s2_c).alpha > 0);
            if (drawGlowShadow) {
                // glow shadow is visible
                shadows.push(`${link.text.s1_c} 0 0 ${link.text.s1_r * link.text.size}px`);
            }

            if (drawDropShadow) {
                let x = link.text.s2_d * Math.cos(link.text.s2_a ?? Math.PI * 0.25) * link.text.size;
                let y = link.text.s2_d * Math.sin(link.text.s2_a ?? Math.PI * 0.25) * link.text.size;

                shadows.push(`${link.text.s2_c} ${x}px ${y}px 0`);

                if (drawGlowShadow) {
                    // glow shadow for the drop shadow
                    shadows.push(`${link.text.s2_c} ${x}px ${y}px ${link.text.s1_r * link.text.size}px`);
                }
            }
            text_element.style.textShadow = shadows.join(",");


            link_element.style.backgroundColor = link.text.b_c;
            link_element.appendChild(text_element);
        }
        else if (link.type === "comments") {
            const comment_url = makeCommentUrl(link, true);
            if (LOCAL || comment_url == null) {

                const comment_placeholder = document.createElement("div");
                comment_placeholder.classList.add("comment-placeholder");
                comment_placeholder.textContent = "Comments only work when the game is uploaded to downpour.games";
                link_element.appendChild(comment_placeholder);
            }
            else {

                const comment_iframe = document.createElement("iframe");
                comment_iframe.style.width = "100%";
                comment_iframe.style.height = "100%";
                comment_iframe.src = comment_url;
                link_element.appendChild(comment_iframe);
            }
        }
        else {
            console.error(`Unknown link type ${link.type}`);
        }



    }

    function makeCommentUrl(link, iframe = false) {
        const match = window.location.pathname.match(/^\/~(?<username>[A-Za-z0-9][A-Za-z0-9_\-]{0,29})\/(?<slug>[A-Za-z0-9\-]+)\/?$/);
        if (match === null) {
            // probably local! or we can't parse the url
            return null;
        }
        const { username, slug } = match.groups;
        const comment_block_id = link.comments.id;

        return `${window.location.origin}/comments/~${username}/${slug}/${comment_block_id}${iframe ? "/iframe" : ""}`;
    }

    function minBy(array, pluck) {
        return array.reduce((min, x) => min && pluck(min) <= pluck(x) ? min : x, null);
    }

    function loadPage(pageId) {
        document.getElementById("svg_filters").innerHTML = ""; //clear old tint filters

        var page = data.pages.find(x => x.id === pageId);

        // if we can't find it, check if it's been renamed
        if (!page) {
            let previously = data.pages.filter(p => p.prev_ids?.includes(pageId));
            if (previously.length > 0) {
                page = minBy(previously, p => p.prevIds?.indexOf(pageId));
            }
        }

        if (!page) {
            return false;
        }

        muteable_links_shown = false;

        if (page.bg_c) {
            document.body.style.background = page.bg_c;
        }

        currentPageWidth = page.width;
        currentPageHeight = page.height;

        var page_div = document.getElementById("page");
        page_div.innerHTML = "";
        page_div.style.width = `${page.width}px`;
        page_div.style.height = `${page.height}px`;

        //needed so that touch-action: manipulation; applies to non-clickable areas
        page_div.addEventListener('click', () => { })

        setPageScale();


        for (const link of page.links) {

            var link_element = document.createElement((link.to || link.type == "comments") ? "a" : "div");
            if (link.type == "comments") {
                //the iframe handles the click
                link_element.style.cursor = "default";
            }
            else if (link.to == "!random") {
                link_element.addEventListener("click", (e) => goToRandom(link.randomTo, e));
                link_element.classList.add("clickable");
            }
            else if (link.to == "!blocker") {
                // do nothing, but block clicks
            }
            else if (link.to === null || link.to === "") {
                //doesn't link anywhere, doesn't block clicks
                link_element.style.pointerEvents = "none";
            }
            else {
                if (link.to.startsWith("#")) {
                    let strippedTo = link.to.substring(1);
                    link_element.href = `?p=${strippedTo}`;
                    link_element.addEventListener("click", (e) => {
                        e.preventDefault();
                        goToPage(strippedTo, e);
                    });
                }
                else {
                    link_element.href = link.to;
                }
                link_element.classList.add("clickable");
            }
            link_element.classList.add("link");
            link_element.style.left = link.x + "px";
            link_element.style.top = link.y + "px";
            link_element.style.width = link.w + "px";
            link_element.style.height = link.h + "px";
            link_element.draggable = false;

            renderLink(link, link_element);

            page_div.appendChild(link_element);
        }

        if (muteable_links_shown) {
            showMuteButton(muted);
        }
        else {
            hideMuteButton();
        }

        window.scrollTo(0, 0);

        // window.addEventListener('load', (event) => {
        preload(data, page);
        // });
        return true;
    }



    function showMuteButton(currentlyMuted) {

        muteButton.hidden = false;

        const muteIcon = document.getElementById("mute_icon");
        const unmuteIcon = document.getElementById("unmute_icon");

        if (currentlyMuted) {
            muteIcon.hidden = false;
            unmuteIcon.hidden = true;
        }
        else {
            muteIcon.hidden = true;
            unmuteIcon.hidden = false;
        }
    }

    function hideMuteButton() {

        muteButton.hidden = true;
    }

    /**
     * Go to page
     * @param {String} to
     * @returns {void}
     * */
    function goToPage(to) {
        console.log("go to page", to);

        const url = new URL(location);
        url.searchParams.set("p", to);
        history.pushState({}, "", url);

        loadPage(to);
        // window.open(to, "_self");
    }

    function goToRandom(randomTo, event) {

        if (randomTo == null || randomTo.length == 0) {
            console.log("go to random page, but no random page options");
        }
        else {

            let cum = 0;
            let weights = [];
            for (let r of randomTo) {
                cum += r.weight ?? 1;
                weights.push(cum);
            }

            var rand = Math.random() * cum;
            for (var i = 0; i < randomTo.length; i++) {
                if (weights[i] >= rand) {
                    if (randomTo[i].to.startsWith("#")) {
                        let strippedTo = randomTo[i].to.substring(1);
                        goToPage(strippedTo);
                    }
                    else {
                        window.open(randomTo[i].to, "_self");
                    }
                    return;
                }
            }

            // we should never hit this point
        }
    }


    let preloaded = {};

    async function preload(data, page) {

        // don't fetch if the current page is still loading
        var currentAssets = [...document.getElementsByClassName("link-asset")];
        while (!currentAssets.every(a => a.complete)) {

            await timeout(100);
        }

        const listen = (elem, eventName) =>
            new Promise((resolve) => elem.addEventListener(eventName, resolve));

        var listeners = [];

        //pages linked to from here
        var linkedPages = getLinkedPages(data, page);
        var assets = linkedPages.flatMap(p => getAssetsForPage(data, p));


        for (const asset of assets) {
            if (asset && preloaded[asset.id] === undefined && asset.path) {
                preloaded[asset.id] = new Image();
                listeners.push(listen(preloaded[asset.id], "load"));

                if (LOCAL) {
                    preloaded[asset.id].src = "media/" + asset.path;
                }
                else {
                    preloaded[asset.id].src = asset.url;
                }
            }
        }
        await Promise.allSettled(listeners);


        listeners = [];

        //pages linked to from pages that are linked to from here
        for (const nextPage of linkedPages) {
            var linkedPages = getLinkedPages(data, nextPage);
            var assets = linkedPages.flatMap(p => getAssetsForPage(data, p));

            for (const asset of assets) {
                if (asset && preloaded[asset.id] === undefined && asset.path) {
                    preloaded[asset.id] = new Image();
                    listeners.push(listen(preloaded[asset.id], "load"));

                    if (LOCAL) {
                        preloaded[asset.id].src = "media/" + asset.path;
                    }
                    else {
                        preloaded[asset.id].src = asset.url;
                    }
                }
            }
        }
        await Promise.allSettled(listeners);
    }

    function getLinkedPages(data, page) {
        let possiblePages = [];
        for (const link of page.links) {
            if (link.to != null && link.to.startsWith("#")) {
                let strippedTo = link.to.substring(1);
                let linkedPage = data.pages.find(x => x.id === strippedTo);
                if (linkedPage) {
                    possiblePages.push(linkedPage);
                }
            }
        }
        return possiblePages;
    }

    function getAssetsForPage(data, page) {
        let assets = [];
        for (const link of page.links) {
            assets.push(data.assets.find(a => a.id === link.image?.asset_id));
        }
        return assets;
    }

    function timeout(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    const fontPaths =
    {
        "Anybody": [{ src: 'local(Anybody), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Anybody.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Anybody.ttf")' }],
        "Epilogue": [
            { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue.ttf")', desc: { style: "normal" } },
            { src: 'local(Epilogue), url("https://downpour-static.b-cdn.net/fonts/woff2/Epilogue-Italic2.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Epilogue-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Epilogue-Italic.ttf")', desc: { style: "italic" } }
        ],
        "Gluten": [{ src: 'local(Gluten), url("https://downpour-static.b-cdn.net/fonts/woff2/Gluten.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Gluten.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Gluten.ttf")' }],
        "Handjet": [{ src: 'local(Handjet), url("https://downpour-static.b-cdn.net/fonts/woff2/Handjet.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Handjet.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Handjet.ttf")' }],
        "Hepta Slab": [{ src: 'local(Hepta Slab), url("https://downpour-static.b-cdn.net/fonts/woff2/HeptaSlab.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/HeptaSlab.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/HeptaSlab.ttf")' }],
        "Recursive": [{ src: 'local(Recursive), url("https://downpour-static.b-cdn.net/fonts/woff2/Recursive.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Recursive.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Recursive.ttf")' }],
        "Sono": [{ src: 'local(Sono), url("https://downpour-static.b-cdn.net/fonts/woff2/Sono.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/Sono.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/Sono.ttf")' }],
        "Source Serif": [
            { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif.ttf")', desc: { style: "normal" } },
            { src: 'local(Source Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/SourceSerif-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/woff/SourceSerif-Italic.woff") format(woff), url("https://downpour-static.b-cdn.net/fonts/ttf/SourceSerif-Italic.ttf")', desc: { style: "italic" } }
        ],
        "Public Sans": [
            { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans.ttf")', desc: { style: "normal" } },
            { src: 'local(Public Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/PublicSans-Italic.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/PublicSans-Italic.ttf")', desc: { style: "italic" } }
        ],
        "Nyght Serif": [
            { src: 'local(Nyght Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/NyghtVariable.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/NyghtVariable.ttf")', desc: { style: "normal" } },
            { src: 'local(Nyght Serif), url("https://downpour-static.b-cdn.net/fonts/woff2/NyghtItalicVariable.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/NyghtItalicVariable.ttf")', desc: { style: "italic" } }
        ],
        "Shantell Sans": [
            { src: 'local(Shantell Sans), url("https://downpour-static.b-cdn.net/fonts/woff2/ShantellSans.woff2") format(woff2), url("https://downpour-static.b-cdn.net/fonts/ttf/ShantellSans.ttf")', },
        ],
    };

    function loadFonts(data) {
        let fontNames = new Set();

        // collect all used fonts
        for (const page of data.pages) {
            for (const link of page.links) {
                if (link.text != null && link.text.font != null) {
                    fontNames.add(link.text.font);
                }
            }
        }

        //load them
        for (const fontName of fontNames) {
            if (fontPaths[fontName]) {
                for (const def of fontPaths[fontName]) {
                    const font = new FontFace(fontName, def.src, def.desc ?? {}); //desc might specify properties, if the font face uses multiple files
                    font.load(); //we could wait on this, but we want to kick off all the loads at once - render whenever they load
                    document.fonts.add(font);
                }
            }
        }
    }
    loadFonts(data);

    //load from hash
    if (window.location.hash && data.pages.some(p => p.id == window.location.hash.substring(1))) {
        loadPage(window.location.hash.substring(1));
    } else {
        loadPage(data.initial_page);
    }

    var queryParams = new URLSearchParams(window.location.search);
    if (queryParams.has("p")) {
        loadPage(queryParams.get("p"));
    }
</script>

</html>